; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

include listing.inc

INCLUDELIB OLDNAMES

?lext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::lext
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	015H
	DW	015H
	DW	010H
	DW	048H
	DW	04eH
	ORG $+2
?dbase@?1??inflate_table@@9@9 DW 01H			; `inflate_table'::`2'::dbase
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	0dH
	DW	011H
	DW	019H
	DW	021H
	DW	031H
	DW	041H
	DW	061H
	DW	081H
	DW	0c1H
	DW	0101H
	DW	0181H
	DW	0201H
	DW	0301H
	DW	0401H
	DW	0601H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01801H
	DW	02001H
	DW	03001H
	DW	04001H
	DW	06001H
	DW	00H
	DW	00H
?lbase@?1??inflate_table@@9@9 DW 03H			; `inflate_table'::`2'::lbase
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0dH
	DW	0fH
	DW	011H
	DW	013H
	DW	017H
	DW	01bH
	DW	01fH
	DW	023H
	DW	02bH
	DW	033H
	DW	03bH
	DW	043H
	DW	053H
	DW	063H
	DW	073H
	DW	083H
	DW	0a3H
	DW	0c3H
	DW	0e3H
	DW	0102H
	DW	00H
	DW	00H
	ORG $+2
?dext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::dext
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	016H
	DW	016H
	DW	017H
	DW	017H
	DW	018H
	DW	018H
	DW	019H
	DW	019H
	DW	01aH
	DW	01aH
	DW	01bH
	DW	01bH
	DW	01cH
	DW	01cH
	DW	01dH
	DW	01dH
	DW	040H
	DW	040H
PUBLIC	inflate_table
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate_table DD imagerel $LN177
	DD	imagerel $LN177+234
	DD	imagerel $unwind$inflate_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$inflate_table DD imagerel $LN177+234
	DD	imagerel $LN177+1095
	DD	imagerel $chain$0$inflate_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflate_table DD imagerel $LN177+1095
	DD	imagerel $LN177+1113
	DD	imagerel $chain$1$inflate_table
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflate_table DD 021H
	DD	imagerel $LN177
	DD	imagerel $LN177+234
	DD	imagerel $unwind$inflate_table
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$inflate_table DD 020521H
	DD	0fc405H
	DD	imagerel $LN177
	DD	imagerel $LN177+234
	DD	imagerel $unwind$inflate_table
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate_table DD 082201H
	DD	0f018f222H
	DD	0d014e016H
	DD	060117012H
	DD	0500f3010H
; Function compile flags: /Ogtpy
; File d:\projectsgit\gamecode4\source\gcc4\3rdparty\zlib-1.2.8\inftrees.c
;	COMDAT inflate_table
_TEXT	SEGMENT
drop$1$ = 0
sym$2$ = 4
root$3$ = 8
next$1$ = 16
base$1$ = 24
mask$1$ = 32
extra$1$ = 40
count$ = 48
offs$ = 80
type$ = 192
lens$ = 200
here$ = 208
codes$ = 208
table$ = 216
bits$ = 224
work$ = 232
inflate_table PROC					; COMDAT

; 39   : {

$LN177:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	55		 push	 rbp
  0000f	53		 push	 rbx
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 8b ec	 mov	 rbp, rsp
  0001b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 40   :     unsigned len;               /* a code's length in bits */
; 41   :     unsigned sym;               /* index of code symbols */
; 42   :     unsigned min, max;          /* minimum and maximum code lengths */
; 43   :     unsigned root;              /* number of index bits for root table */
; 44   :     unsigned curr;              /* number of index bits for current table */
; 45   :     unsigned drop;              /* code bits to drop for sub-table */
; 46   :     int left;                   /* number of prefix codes available */
; 47   :     unsigned used;              /* code entries in table used */
; 48   :     unsigned huff;              /* Huffman code */
; 49   :     unsigned incr;              /* for incrementing code, index */
; 50   :     unsigned fill;              /* index for replicating entries */
; 51   :     unsigned low;               /* low bits for current root entry */
; 52   :     unsigned mask;              /* mask for low root bits */
; 53   :     code here;                  /* table entry for duplication */
; 54   :     code FAR *next;             /* next available space in table */
; 55   :     const unsigned short FAR *base;     /* base value table to use */
; 56   :     const unsigned short FAR *extra;    /* extra bits table to use */
; 57   :     int end;                    /* use base and extra for symbol > end */
; 58   :     unsigned short count[MAXBITS+1];    /* number of codes of each length */
; 59   :     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
; 60   :     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
; 61   :         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
; 62   :         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
; 63   :     static const unsigned short lext[31] = { /* Length codes 257..285 extra */
; 64   :         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
; 65   :         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78};
; 66   :     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
; 67   :         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
; 68   :         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
; 69   :         8193, 12289, 16385, 24577, 0, 0};
; 70   :     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
; 71   :         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
; 72   :         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
; 73   :         28, 28, 29, 29, 64, 64};
; 74   : 
; 75   :     /*
; 76   :        Process a set of code lengths to create a canonical Huffman code.  The
; 77   :        code lengths are lens[0..codes-1].  Each length corresponds to the
; 78   :        symbols 0..codes-1.  The Huffman code is generated by first sorting the
; 79   :        symbols by length from short to long, and retaining the symbol order
; 80   :        for codes with equal lengths.  Then the code starts with all zero bits
; 81   :        for the first code of the shortest length, and the codes are integer
; 82   :        increments for the same length, and zeros are appended as the length
; 83   :        increases.  For the deflate format, these bits are stored backwards
; 84   :        from their more natural integer increment ordering, and so when the
; 85   :        decoding tables are built in the large loop below, the integer codes
; 86   :        are incremented backwards.
; 87   : 
; 88   :        This routine assumes, but does not check, that all of the entries in
; 89   :        lens[] are in the range 0..MAXBITS.  The caller must assure this.
; 90   :        1..MAXBITS is interpreted as that code length.  zero means that that
; 91   :        symbol does not occur in this code.
; 92   : 
; 93   :        The codes are sorted by computing a count of codes for each length,
; 94   :        creating from that a table of starting indices for each length in the
; 95   :        sorted table, and then entering the symbols in order in the sorted
; 96   :        table.  The sorted table is work[], with that space being provided by
; 97   :        the caller.
; 98   : 
; 99   :        The length counts are used for other purposes as well, i.e. finding
; 100  :        the minimum and maximum length codes, determining if there are any
; 101  :        codes at all, checking for a valid set of lengths, and looking ahead
; 102  :        at length counts to determine sub-table sizes when building the
; 103  :        decoding tables.
; 104  :      */
; 105  : 
; 106  :     /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
; 107  :     for (len = 0; len <= MAXBITS; len++)
; 108  :         count[len] = 0;

  00022	45 33 ed	 xor	 r13d, r13d
  00025	8b f1		 mov	 esi, ecx
  00027	48 8d 7d b0	 lea	 rdi, QWORD PTR count$[rbp-128]
  0002b	b9 10 00 00 00	 mov	 ecx, 16
  00030	41 0f b7 c5	 movzx	 eax, r13w
  00034	4d 8b f9	 mov	 r15, r9
  00037	45 8b d8	 mov	 r11d, r8d
  0003a	48 8b da	 mov	 rbx, rdx
  0003d	66 f3 ab	 rep stosw

; 109  :     for (sym = 0; sym < codes; sym++)

  00040	45 85 c0	 test	 r8d, r8d
  00043	74 1c		 je	 SHORT $LN57@inflate_ta
  00045	48 8b fa	 mov	 rdi, rdx
  00048	45 8b c3	 mov	 r8d, r11d
  0004b	0f 1f 44 00 00	 npad	 5
$LL59@inflate_ta:

; 110  :         count[lens[sym]]++;

  00050	0f b7 07	 movzx	 eax, WORD PTR [rdi]
  00053	48 8d 7f 02	 lea	 rdi, QWORD PTR [rdi+2]
  00057	66 ff 44 45 b0	 inc	 WORD PTR count$[rbp+rax*2-128]
  0005c	49 ff c8	 dec	 r8
  0005f	75 ef		 jne	 SHORT $LL59@inflate_ta
$LN57@inflate_ta:

; 111  : 
; 112  :     /* bound code lengths, force root to be within code lengths */
; 113  :     root = *bits;

  00061	48 8b 55 60	 mov	 rdx, QWORD PTR bits$[rbp-128]

; 114  :     for (max = MAXBITS; max >= 1; max--)

  00065	41 b9 0f 00 00
	00		 mov	 r9d, 15
  0006b	41 83 ce ff	 or	 r14d, -1		; ffffffffH
  0006f	44 8b 02	 mov	 r8d, DWORD PTR [rdx]
$LL56@inflate_ta:

; 115  :         if (count[max] != 0) break;

  00072	41 8b c1	 mov	 eax, r9d
  00075	66 44 39 6c 45
	b0		 cmp	 WORD PTR count$[rbp+rax*2-128], r13w
  0007b	75 09		 jne	 SHORT $LN77@inflate_ta

; 114  :     for (max = MAXBITS; max >= 1; max--)

  0007d	45 03 ce	 add	 r9d, r14d
  00080	41 83 f9 01	 cmp	 r9d, 1
  00084	73 ec		 jae	 SHORT $LL56@inflate_ta
$LN77@inflate_ta:

; 116  :     if (root > max) root = max;

  00086	45 3b c1	 cmp	 r8d, r9d
  00089	45 0f 47 c1	 cmova	 r8d, r9d

; 117  :     if (max == 0) {                     /* no symbols to code at all */

  0008d	45 85 c9	 test	 r9d, r9d
  00090	75 29		 jne	 SHORT $LN51@inflate_ta

; 118  :         here.op = (unsigned char)64;    /* invalid code marker */
; 119  :         here.bits = (unsigned char)1;
; 120  :         here.val = (unsigned short)0;
; 121  :         *(*table)++ = here;             /* make a table to force an error */

  00092	49 8b 0f	 mov	 rcx, QWORD PTR [r15]
  00095	c7 45 50 40 01
	00 00		 mov	 DWORD PTR here$[rbp-128], 320 ; 00000140H
  0009c	8b 45 50	 mov	 eax, DWORD PTR here$[rbp-128]
  0009f	89 01		 mov	 DWORD PTR [rcx], eax
  000a1	49 83 07 04	 add	 QWORD PTR [r15], 4
  000a5	49 8b 0f	 mov	 rcx, QWORD PTR [r15]
  000a8	89 01		 mov	 DWORD PTR [rcx], eax
  000aa	49 83 07 04	 add	 QWORD PTR [r15], 4

; 122  :         *(*table)++ = here;
; 123  :         *bits = 1;

  000ae	c7 02 01 00 00
	00		 mov	 DWORD PTR [rdx], 1

; 124  :         return 0;     /* no symbols, but wait for decoding to report error */

  000b4	33 c0		 xor	 eax, eax
  000b6	e9 8c 03 00 00	 jmp	 $LN63@inflate_ta
$LN51@inflate_ta:

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  000bb	41 ba 01 00 00
	00		 mov	 r10d, 1
  000c1	45 3b ca	 cmp	 r9d, r10d
  000c4	76 1c		 jbe	 SHORT $LN163@inflate_ta
  000c6	48 8d 45 b2	 lea	 rax, QWORD PTR count$[rbp-126]
  000ca	66 0f 1f 44 00
	00		 npad	 6
$LL50@inflate_ta:

; 127  :         if (count[min] != 0) break;

  000d0	66 44 39 28	 cmp	 WORD PTR [rax], r13w
  000d4	75 0c		 jne	 SHORT $LN163@inflate_ta

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  000d6	41 ff c2	 inc	 r10d
  000d9	48 83 c0 02	 add	 rax, 2
  000dd	45 3b d1	 cmp	 r10d, r9d
  000e0	72 ee		 jb	 SHORT $LL50@inflate_ta
$LN163@inflate_ta:

; 128  :     if (root < min) root = min;

  000e2	45 3b c2	 cmp	 r8d, r10d

; 129  : 
; 130  :     /* check for an over-subscribed or incomplete set of lengths */
; 131  :     left = 1;

  000e5	bf 01 00 00 00	 mov	 edi, 1
  000ea	4c 89 64 24 78	 mov	 QWORD PTR [rsp+120], r12
  000ef	45 0f 42 c2	 cmovb	 r8d, r10d

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  000f3	8b d7		 mov	 edx, edi
  000f5	44 89 45 88	 mov	 DWORD PTR root$3$[rbp-128], r8d
  000f9	0f 1f 80 00 00
	00 00		 npad	 7
$LL45@inflate_ta:

; 133  :         left <<= 1;
; 134  :         left -= count[len];

  00100	8b c2		 mov	 eax, edx
  00102	03 ff		 add	 edi, edi
  00104	0f b7 4c 45 b0	 movzx	 ecx, WORD PTR count$[rbp+rax*2-128]
  00109	2b f9		 sub	 edi, ecx

; 135  :         if (left < 0) return -1;        /* over-subscribed */

  0010b	0f 88 2e 03 00
	00		 js	 $LN79@inflate_ta

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  00111	ff c2		 inc	 edx
  00113	83 fa 0f	 cmp	 edx, 15
  00116	76 e8		 jbe	 SHORT $LL45@inflate_ta

; 136  :     }
; 137  :     if (left > 0 && (type == CODES || max != 1))

  00118	85 ff		 test	 edi, edi
  0011a	7e 12		 jle	 SHORT $LN41@inflate_ta
  0011c	85 f6		 test	 esi, esi
  0011e	0f 84 1b 03 00
	00		 je	 $LN79@inflate_ta
  00124	41 83 f9 01	 cmp	 r9d, 1
  00128	0f 85 11 03 00
	00		 jne	 $LN79@inflate_ta
$LN41@inflate_ta:

; 138  :         return -1;                      /* incomplete set */
; 139  : 
; 140  :     /* generate offsets into symbol table for each length for sorting */
; 141  :     offs[1] = 0;

  0012e	66 44 89 6d d2	 mov	 WORD PTR offs$[rbp-126], r13w

; 142  :     for (len = 1; len < MAXBITS; len++)

  00133	49 8b cd	 mov	 rcx, r13
  00136	ba 0e 00 00 00	 mov	 edx, 14
  0013b	0f 1f 44 00 00	 npad	 5
$LL39@inflate_ta:

; 143  :         offs[len + 1] = offs[len] + count[len];

  00140	0f b7 44 0d b2	 movzx	 eax, WORD PTR count$[rbp+rcx-126]
  00145	48 8d 49 02	 lea	 rcx, QWORD PTR [rcx+2]
  00149	66 03 44 0d d0	 add	 ax, WORD PTR offs$[rbp+rcx-128]
  0014e	66 89 44 0d d2	 mov	 WORD PTR offs$[rbp+rcx-126], ax
  00153	48 ff ca	 dec	 rdx
  00156	75 e8		 jne	 SHORT $LL39@inflate_ta

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  00158	41 8b fd	 mov	 edi, r13d
  0015b	45 85 db	 test	 r11d, r11d
  0015e	74 2e		 je	 SHORT $LN34@inflate_ta
  00160	48 8b d3	 mov	 rdx, rbx
  00163	48 8b 5d 68	 mov	 rbx, QWORD PTR work$[rbp-128]
$LL36@inflate_ta:

; 147  :         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

  00167	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  0016a	66 85 c0	 test	 ax, ax
  0016d	74 14		 je	 SHORT $LN35@inflate_ta
  0016f	0f b7 c0	 movzx	 eax, ax
  00172	0f b7 4c 45 d0	 movzx	 ecx, WORD PTR offs$[rbp+rax*2-128]
  00177	66 89 3c 4b	 mov	 WORD PTR [rbx+rcx*2], di
  0017b	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  0017e	66 ff 44 45 d0	 inc	 WORD PTR offs$[rbp+rax*2-128]
$LN35@inflate_ta:

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  00183	ff c7		 inc	 edi
  00185	48 83 c2 02	 add	 rdx, 2
  00189	41 3b fb	 cmp	 edi, r11d
  0018c	72 d9		 jb	 SHORT $LL36@inflate_ta
$LN34@inflate_ta:

; 195  :         extra = dext;
; 196  :         end = -1;

  0018e	48 8b 7d 68	 mov	 rdi, QWORD PTR work$[rbp-128]
  00192	8b ce		 mov	 ecx, esi
  00194	85 f6		 test	 esi, esi
  00196	74 4a		 je	 SHORT $LN30@inflate_ta

; 148  : 
; 149  :     /*
; 150  :        Create and fill in decoding tables.  In this loop, the table being
; 151  :        filled is at next and has curr index bits.  The code being used is huff
; 152  :        with length len.  That code is converted to an index by dropping drop
; 153  :        bits off of the bottom.  For codes where len is less than drop + curr,
; 154  :        those top drop + curr - len bits are incremented through all values to
; 155  :        fill the table with replicated entries.
; 156  : 
; 157  :        root is the number of index bits for the root table.  When len exceeds
; 158  :        root, sub-tables are created pointed to by the root entry with an index
; 159  :        of the low root bits of huff.  This is saved in low to check for when a
; 160  :        new sub-table should be started.  drop is zero when the root table is
; 161  :        being filled, and drop is root when sub-tables are being filled.
; 162  : 
; 163  :        When a new sub-table is needed, it is necessary to look ahead in the
; 164  :        code lengths to determine what size sub-table is needed.  The length
; 165  :        counts are used for this, and so count[] is decremented as codes are
; 166  :        entered in the tables.
; 167  : 
; 168  :        used keeps track of how many table entries have been allocated from the
; 169  :        provided *table space.  It is checked for LENS and DIST tables against
; 170  :        the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
; 171  :        the initial root table size constants.  See the comments in inftrees.h
; 172  :        for more information.
; 173  : 
; 174  :        sym increments through all symbols, and the loop terminates when
; 175  :        all codes of length max, i.e. all codes, have been processed.  This
; 176  :        routine permits incomplete codes, so another loop after this one fills
; 177  :        in the rest of the decoding tables with invalid code markers.
; 178  :      */
; 179  : 
; 180  :     /* set up for code type */
; 181  :     switch (type) {

  00198	ff c9		 dec	 ecx
  0019a	74 1c		 je	 SHORT $LN29@inflate_ta

; 193  :     default:            /* DISTS */
; 194  :         base = dbase;

  0019c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?dbase@?1??inflate_table@@9@9

; 195  :         extra = dext;
; 196  :         end = -1;

  001a3	41 83 cc ff	 or	 r12d, -1
  001a7	48 89 45 98	 mov	 QWORD PTR base$1$[rbp-128], rax
  001ab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?dext@?1??inflate_table@@9@9
  001b2	48 89 45 a8	 mov	 QWORD PTR extra$1$[rbp-128], rax
  001b6	eb 38		 jmp	 SHORT $LN31@inflate_ta
$LN29@inflate_ta:

; 185  :         break;
; 186  :     case LENS:
; 187  :         base = lbase;
; 188  :         base -= 257;

  001b8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lbase@?1??inflate_table@@9@9

; 189  :         extra = lext;
; 190  :         extra -= 257;
; 191  :         end = 256;

  001bf	41 bc 00 01 00
	00		 mov	 r12d, 256		; 00000100H
  001c5	48 2d 02 02 00
	00		 sub	 rax, 514		; 00000202H
  001cb	48 89 45 98	 mov	 QWORD PTR base$1$[rbp-128], rax
  001cf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lext@?1??inflate_table@@9@9
  001d6	48 2d 02 02 00
	00		 sub	 rax, 514		; 00000202H
  001dc	48 89 45 a8	 mov	 QWORD PTR extra$1$[rbp-128], rax

; 192  :         break;

  001e0	eb 0e		 jmp	 SHORT $LN31@inflate_ta
$LN30@inflate_ta:

; 182  :     case CODES:
; 183  :         base = extra = work;    /* dummy value--not used */

  001e2	48 89 7d a8	 mov	 QWORD PTR extra$1$[rbp-128], rdi
  001e6	48 89 7d 98	 mov	 QWORD PTR base$1$[rbp-128], rdi

; 184  :         end = 19;

  001ea	41 bc 13 00 00
	00		 mov	 r12d, 19
$LN31@inflate_ta:

; 197  :     }
; 198  : 
; 199  :     /* initialize state for loop */
; 200  :     huff = 0;                   /* starting code */
; 201  :     sym = 0;                    /* starting code symbol */
; 202  :     len = min;                  /* starting code length */
; 203  :     next = *table;              /* current table to fill in */

  001f0	49 8b 1f	 mov	 rbx, QWORD PTR [r15]

; 204  :     curr = root;                /* current table index bits */
; 205  :     drop = 0;                   /* current bits to drop from code for index */
; 206  :     low = (unsigned)(-1);       /* trigger new sub-table when len > root */
; 207  :     used = 1U << root;          /* use root table entries */
; 208  :     mask = used - 1;            /* mask for comparing low */
; 209  : 
; 210  :     /* check available table space */
; 211  :     if ((type == LENS && used > ENOUGH_LENS) ||
; 212  :         (type == DISTS && used > ENOUGH_DISTS))

  001f3	44 8b 7d 40	 mov	 r15d, DWORD PTR type$[rbp-128]
  001f7	41 8b d5	 mov	 edx, r13d
  001fa	41 8b c8	 mov	 ecx, r8d
  001fd	be 01 00 00 00	 mov	 esi, 1
  00202	45 8b dd	 mov	 r11d, r13d
  00205	d3 e6		 shl	 esi, cl
  00207	44 89 6d 84	 mov	 DWORD PTR sym$2$[rbp-128], r13d
  0020b	48 89 5d 90	 mov	 QWORD PTR next$1$[rbp-128], rbx
  0020f	8d 46 ff	 lea	 eax, DWORD PTR [rsi-1]
  00212	89 55 80	 mov	 DWORD PTR drop$1$[rbp-128], edx
  00215	44 8b ee	 mov	 r13d, esi
  00218	89 45 a0	 mov	 DWORD PTR mask$1$[rbp-128], eax
  0021b	41 83 ff 01	 cmp	 r15d, 1
  0021f	75 08		 jne	 SHORT $LN25@inflate_ta
  00221	81 fe 54 03 00
	00		 cmp	 esi, 852		; 00000354H
  00227	eb 0c		 jmp	 SHORT $LN175@inflate_ta
$LN25@inflate_ta:
  00229	41 83 ff 02	 cmp	 r15d, 2
  0022d	75 0c		 jne	 SHORT $LN159@inflate_ta
  0022f	81 fe 50 02 00
	00		 cmp	 esi, 592		; 00000250H
$LN175@inflate_ta:
  00235	0f 87 fd 01 00
	00		 ja	 $LN3@inflate_ta
$LN159@inflate_ta:
  0023b	8b ca		 mov	 ecx, edx
  0023d	eb 11		 jmp	 SHORT $LL24@inflate_ta
  0023f	90		 npad	 1
$LL165@inflate_ta:
  00240	48 8b 5d 90	 mov	 rbx, QWORD PTR next$1$[rbp-128]
  00244	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL24@inflate_ta:

; 213  :         return 1;
; 214  : 
; 215  :     /* process all codes and make table entries */
; 216  :     for (;;) {
; 217  :         /* create table entry */
; 218  :         here.bits = (unsigned char)(len - drop);

  00250	41 0f b6 c2	 movzx	 eax, r10b
  00254	2a c2		 sub	 al, dl
  00256	88 45 51	 mov	 BYTE PTR here$[rbp-127], al

; 219  :         if ((int)(work[sym]) < end) {

  00259	8b c1		 mov	 eax, ecx
  0025b	0f b7 0c 47	 movzx	 ecx, WORD PTR [rdi+rax*2]
  0025f	41 3b cc	 cmp	 ecx, r12d
  00262	7d 0a		 jge	 SHORT $LN172@inflate_ta

; 220  :             here.op = (unsigned char)0;

  00264	c6 45 50 00	 mov	 BYTE PTR here$[rbp-128], 0

; 221  :             here.val = work[sym];

  00268	66 89 4d 52	 mov	 WORD PTR here$[rbp-126], cx
  0026c	eb 24		 jmp	 SHORT $LN19@inflate_ta
$LN172@inflate_ta:

; 222  :         }
; 223  :         else if ((int)(work[sym]) > end) {

  0026e	7e 18		 jle	 SHORT $LN20@inflate_ta

; 224  :             here.op = (unsigned char)(extra[work[sym]]);

  00270	48 8b 45 a8	 mov	 rax, QWORD PTR extra$1$[rbp-128]
  00274	48 03 c9	 add	 rcx, rcx
  00277	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0027b	88 45 50	 mov	 BYTE PTR here$[rbp-128], al

; 225  :             here.val = base[work[sym]];

  0027e	48 8b 45 98	 mov	 rax, QWORD PTR base$1$[rbp-128]
  00282	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]

; 226  :         }
; 227  :         else {

  00286	eb 06		 jmp	 SHORT $LN173@inflate_ta
$LN20@inflate_ta:

; 228  :             here.op = (unsigned char)(32 + 64);         /* end of block */

  00288	c6 45 50 60	 mov	 BYTE PTR here$[rbp-128], 96 ; 00000060H

; 229  :             here.val = 0;

  0028c	33 c0		 xor	 eax, eax
$LN173@inflate_ta:
  0028e	66 89 45 52	 mov	 WORD PTR here$[rbp-126], ax
$LN19@inflate_ta:

; 230  :         }
; 231  : 
; 232  :         /* replicate for those indices with low len bits equal to huff */
; 233  :         incr = 1U << (len - drop);

  00292	8b 45 50	 mov	 eax, DWORD PTR here$[rbp-128]
  00295	41 8b ca	 mov	 ecx, r10d
  00298	41 b8 01 00 00
	00		 mov	 r8d, 1
  0029e	2b ca		 sub	 ecx, edx
  002a0	41 8b d3	 mov	 edx, r11d

; 234  :         fill = 1U << curr;

  002a3	8b fe		 mov	 edi, esi
  002a5	41 d3 e0	 shl	 r8d, cl
  002a8	8b 4d 80	 mov	 ecx, DWORD PTR drop$1$[rbp-128]
  002ab	d3 ea		 shr	 edx, cl
  002ad	03 d6		 add	 edx, esi
  002af	90		 npad	 1
$LL18@inflate_ta:

; 235  :         min = fill;                 /* save offset to next table */
; 236  :         do {
; 237  :             fill -= incr;

  002b0	41 2b d0	 sub	 edx, r8d

; 238  :             next[(huff >> drop) + fill] = here;

  002b3	89 04 93	 mov	 DWORD PTR [rbx+rdx*4], eax
  002b6	41 2b f8	 sub	 edi, r8d

; 239  :         } while (fill != 0);

  002b9	75 f5		 jne	 SHORT $LL18@inflate_ta

; 240  : 
; 241  :         /* backwards increment the len-bit code huff */
; 242  :         incr = 1U << (len - 1);

  002bb	41 8d 4a ff	 lea	 ecx, DWORD PTR [r10-1]
  002bf	ba 01 00 00 00	 mov	 edx, 1
  002c4	d3 e2		 shl	 edx, cl

; 243  :         while (huff & incr)

  002c6	41 85 d3	 test	 edx, r11d
  002c9	74 0c		 je	 SHORT $LN14@inflate_ta
  002cb	0f 1f 44 00 00	 npad	 5
$LL15@inflate_ta:

; 244  :             incr >>= 1;

  002d0	d1 ea		 shr	 edx, 1
  002d2	41 85 d3	 test	 edx, r11d
  002d5	75 f9		 jne	 SHORT $LL15@inflate_ta
$LN14@inflate_ta:

; 245  :         if (incr != 0) {

  002d7	85 d2		 test	 edx, edx
  002d9	74 0d		 je	 SHORT $LN13@inflate_ta

; 246  :             huff &= incr - 1;

  002db	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  002de	44 23 d8	 and	 r11d, eax

; 247  :             huff += incr;

  002e1	44 03 da	 add	 r11d, edx

; 248  :         }
; 249  :         else

  002e4	33 d2		 xor	 edx, edx
  002e6	eb 05		 jmp	 SHORT $LN12@inflate_ta
$LN13@inflate_ta:

; 250  :             huff = 0;

  002e8	33 d2		 xor	 edx, edx
  002ea	44 8b da	 mov	 r11d, edx
$LN12@inflate_ta:

; 251  : 
; 252  :         /* go to next symbol, update count, len */
; 253  :         sym++;

  002ed	8b 4d 84	 mov	 ecx, DWORD PTR sym$2$[rbp-128]

; 254  :         if (--(count[len]) == 0) {

  002f0	41 8b c2	 mov	 eax, r10d
  002f3	bf ff ff 00 00	 mov	 edi, 65535		; 0000ffffH
  002f8	ff c1		 inc	 ecx
  002fa	66 01 7c 45 b0	 add	 WORD PTR count$[rbp+rax*2-128], di
  002ff	89 4d 84	 mov	 DWORD PTR sym$2$[rbp-128], ecx
  00302	75 1f		 jne	 SHORT $LN166@inflate_ta

; 255  :             if (len == max) break;

  00304	45 3b d1	 cmp	 r10d, r9d
  00307	0f 84 f2 00 00
	00		 je	 $LN81@inflate_ta

; 256  :             len = lens[work[sym]];

  0030d	48 8b 7d 68	 mov	 rdi, QWORD PTR work$[rbp-128]
  00311	48 8b 45 48	 mov	 rax, QWORD PTR lens$[rbp-128]
  00315	0f b7 0c 4f	 movzx	 ecx, WORD PTR [rdi+rcx*2]
  00319	44 0f b7 14 48	 movzx	 r10d, WORD PTR [rax+rcx*2]
  0031e	8b 4d 84	 mov	 ecx, DWORD PTR sym$2$[rbp-128]
  00321	eb 04		 jmp	 SHORT $LN11@inflate_ta
$LN166@inflate_ta:
  00323	48 8b 7d 68	 mov	 rdi, QWORD PTR work$[rbp-128]
$LN11@inflate_ta:

; 257  :         }
; 258  : 
; 259  :         /* create new sub-table if needed */
; 260  :         if (len > root && (huff & mask) != low) {

  00327	44 8b 45 88	 mov	 r8d, DWORD PTR root$3$[rbp-128]
  0032b	8b 55 80	 mov	 edx, DWORD PTR drop$1$[rbp-128]
  0032e	45 3b d0	 cmp	 r10d, r8d
  00331	0f 86 19 ff ff
	ff		 jbe	 $LL24@inflate_ta
  00337	8b 5d a0	 mov	 ebx, DWORD PTR mask$1$[rbp-128]
  0033a	41 23 db	 and	 ebx, r11d
  0033d	41 3b de	 cmp	 ebx, r14d
  00340	0f 84 fa fe ff
	ff		 je	 $LL165@inflate_ta

; 261  :             /* if first time, transition to sub-tables */
; 262  :             if (drop == 0)
; 263  :                 drop = root;
; 264  : 
; 265  :             /* increment past last table */
; 266  :             next += min;            /* here min is 1 << curr */

  00346	48 8b 4d 90	 mov	 rcx, QWORD PTR next$1$[rbp-128]
  0034a	85 d2		 test	 edx, edx

; 267  : 
; 268  :             /* determine length of next table */
; 269  :             curr = len - drop;
; 270  :             left = (int)(1 << curr);

  0034c	b8 01 00 00 00	 mov	 eax, 1
  00351	41 0f 44 d0	 cmove	 edx, r8d
  00355	48 8d 0c b1	 lea	 rcx, QWORD PTR [rcx+rsi*4]
  00359	45 8b c2	 mov	 r8d, r10d
  0035c	44 2b c2	 sub	 r8d, edx
  0035f	48 89 4d 90	 mov	 QWORD PTR next$1$[rbp-128], rcx
  00363	89 55 80	 mov	 DWORD PTR drop$1$[rbp-128], edx

; 271  :             while (curr + drop < max) {

  00366	42 8d 3c 02	 lea	 edi, DWORD PTR [rdx+r8]
  0036a	41 8b c8	 mov	 ecx, r8d
  0036d	d3 e0		 shl	 eax, cl
  0036f	41 3b f9	 cmp	 edi, r9d
  00372	73 17		 jae	 SHORT $LN164@inflate_ta
$LL7@inflate_ta:

; 272  :                 left -= count[curr + drop];

  00374	0f b7 54 7d b0	 movzx	 edx, WORD PTR count$[rbp+rdi*2-128]
  00379	2b c2		 sub	 eax, edx

; 273  :                 if (left <= 0) break;

  0037b	85 c0		 test	 eax, eax
  0037d	7e 0c		 jle	 SHORT $LN164@inflate_ta

; 274  :                 curr++;

  0037f	ff c7		 inc	 edi
  00381	41 ff c0	 inc	 r8d

; 275  :                 left <<= 1;

  00384	03 c0		 add	 eax, eax
  00386	41 3b f9	 cmp	 edi, r9d
  00389	72 e9		 jb	 SHORT $LL7@inflate_ta
$LN164@inflate_ta:

; 276  :             }
; 277  : 
; 278  :             /* check for enough space */
; 279  :             used += 1U << curr;
; 280  :             if ((type == LENS && used > ENOUGH_LENS) ||
; 281  :                 (type == DISTS && used > ENOUGH_DISTS))

  0038b	44 8b 7d 40	 mov	 r15d, DWORD PTR type$[rbp-128]
  0038f	41 8b c8	 mov	 ecx, r8d
  00392	be 01 00 00 00	 mov	 esi, 1
  00397	d3 e6		 shl	 esi, cl
  00399	44 03 ee	 add	 r13d, esi
  0039c	41 83 ff 01	 cmp	 r15d, 1
  003a0	75 09		 jne	 SHORT $LN2@inflate_ta
  003a2	41 81 fd 54 03
	00 00		 cmp	 r13d, 852		; 00000354H
  003a9	eb 0d		 jmp	 SHORT $LN174@inflate_ta
$LN2@inflate_ta:
  003ab	41 83 ff 02	 cmp	 r15d, 2
  003af	75 09		 jne	 SHORT $LN4@inflate_ta
  003b1	41 81 fd 50 02
	00 00		 cmp	 r13d, 592		; 00000250H
$LN174@inflate_ta:
  003b8	77 7e		 ja	 SHORT $LN3@inflate_ta
$LN4@inflate_ta:

; 283  : 
; 284  :             /* point entry in root table to sub-table */
; 285  :             low = huff & mask;
; 286  :             (*table)[low].op = (unsigned char)curr;

  003ba	48 8b 7d 58	 mov	 rdi, QWORD PTR table$[rbp-128]

; 287  :             (*table)[low].bits = (unsigned char)root;

  003be	8b 4d 88	 mov	 ecx, DWORD PTR root$3$[rbp-128]
  003c1	48 8d 14 9d 00
	00 00 00	 lea	 rdx, QWORD PTR [rbx*4]
  003c9	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  003cc	44 8b f3	 mov	 r14d, ebx

; 288  :             (*table)[low].val = (unsigned short)(next - *table);

  003cf	48 8b 5d 90	 mov	 rbx, QWORD PTR next$1$[rbp-128]
  003d3	44 88 04 02	 mov	 BYTE PTR [rdx+rax], r8b
  003d7	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  003da	88 4c 02 01	 mov	 BYTE PTR [rdx+rax+1], cl
  003de	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]

; 289  :         }
; 290  :     }

  003e1	48 8b 7d 68	 mov	 rdi, QWORD PTR work$[rbp-128]
  003e5	48 8b c3	 mov	 rax, rbx
  003e8	48 2b c1	 sub	 rax, rcx
  003eb	48 c1 f8 02	 sar	 rax, 2
  003ef	66 89 44 0a 02	 mov	 WORD PTR [rdx+rcx+2], ax
  003f4	8b 55 80	 mov	 edx, DWORD PTR drop$1$[rbp-128]
  003f7	8b 4d 84	 mov	 ecx, DWORD PTR sym$2$[rbp-128]
  003fa	e9 51 fe ff ff	 jmp	 $LL24@inflate_ta
$LN81@inflate_ta:

; 291  : 
; 292  :     /* fill in remaining table entry if code is incomplete (guaranteed to have
; 293  :        at most one remaining entry, since if the code is incomplete, the
; 294  :        maximum code length that was allowed to get this far is one bit) */
; 295  :     if (huff != 0) {

  003ff	45 85 db	 test	 r11d, r11d
  00402	74 19		 je	 SHORT $LN1@inflate_ta

; 296  :         here.op = (unsigned char)64;            /* invalid code marker */
; 297  :         here.bits = (unsigned char)(len - drop);

  00404	44 2a 55 80	 sub	 r10b, BYTE PTR drop$1$[rbp-128]
  00408	c6 45 50 40	 mov	 BYTE PTR here$[rbp-128], 64 ; 00000040H

; 298  :         here.val = (unsigned short)0;

  0040c	66 89 55 52	 mov	 WORD PTR here$[rbp-126], dx
  00410	44 88 55 51	 mov	 BYTE PTR here$[rbp-127], r10b

; 299  :         next[huff] = here;

  00414	8b 45 50	 mov	 eax, DWORD PTR here$[rbp-128]
  00417	41 8b cb	 mov	 ecx, r11d
  0041a	89 04 8b	 mov	 DWORD PTR [rbx+rcx*4], eax
$LN1@inflate_ta:

; 300  :     }
; 301  : 
; 302  :     /* set return parameters */
; 303  :     *table += used;

  0041d	48 8b 4d 58	 mov	 rcx, QWORD PTR table$[rbp-128]
  00421	41 8b c5	 mov	 eax, r13d
  00424	48 c1 e0 02	 shl	 rax, 2
  00428	48 01 01	 add	 QWORD PTR [rcx], rax

; 304  :     *bits = root;

  0042b	8b 45 88	 mov	 eax, DWORD PTR root$3$[rbp-128]
  0042e	48 8b 4d 60	 mov	 rcx, QWORD PTR bits$[rbp-128]
  00432	89 01		 mov	 DWORD PTR [rcx], eax

; 305  :     return 0;

  00434	33 c0		 xor	 eax, eax
  00436	eb 0a		 jmp	 SHORT $LN171@inflate_ta
$LN3@inflate_ta:

; 282  :                 return 1;

  00438	b8 01 00 00 00	 mov	 eax, 1
  0043d	eb 03		 jmp	 SHORT $LN171@inflate_ta
$LN79@inflate_ta:

; 135  :         if (left < 0) return -1;        /* over-subscribed */

  0043f	83 c8 ff	 or	 eax, -1
$LN171@inflate_ta:
  00442	4c 8b 64 24 78	 mov	 r12, QWORD PTR [rsp+120]
$LN63@inflate_ta:

; 306  : }

  00447	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  0044e	41 5f		 pop	 r15
  00450	41 5e		 pop	 r14
  00452	41 5d		 pop	 r13
  00454	5f		 pop	 rdi
  00455	5e		 pop	 rsi
  00456	5b		 pop	 rbx
  00457	5d		 pop	 rbp
  00458	c3		 ret	 0
inflate_table ENDP
_TEXT	ENDS
END
