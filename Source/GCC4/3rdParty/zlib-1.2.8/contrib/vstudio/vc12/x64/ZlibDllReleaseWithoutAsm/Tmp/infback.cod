; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@	; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ ; `string'
PUBLIC	??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ ; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@	; `string'
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ ; `string'
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ DB 'invalid dis'
	DB	'tance too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@ DB 'invalid distance code'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ DB 'invalid litera'
	DB	'l/length code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@ DB 'invalid distances set'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ DB 'invalid litera'
	DB	'l/lengths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
CONST	SEGMENT
??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ DB 'invalid '
	DB	'code -- missing end-of-block', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ DB 'invalid bit leng'
	DB	'th repeat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ DB 'invalid code leng'
	DB	'ths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ DB 'too many le'
	DB	'ngth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ DB 'invalid store'
	DB	'd block lengths', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@ DB 'invalid block type', 00H ; `string'
	ORG $+10
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?order@?1??inflateBack@@9@9 DW 010H			; `inflateBack'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
	ORG $+10
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
PUBLIC	inflateBackEnd
PUBLIC	inflateBack
PUBLIC	inflateBackInit_
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBackEnd DD imagerel $LN6
	DD	imagerel $LN6+65
	DD	imagerel $unwind$inflateBackEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBack DD imagerel $LN494
	DD	imagerel $LN494+66
	DD	imagerel $unwind$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateBack DD imagerel $LN494+66
	DD	imagerel $LN494+3696
	DD	imagerel $chain$3$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateBack DD imagerel $LN494+3696
	DD	imagerel $LN494+3792
	DD	imagerel $chain$4$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBackInit_ DD imagerel $LN13
	DD	imagerel $LN13+83
	DD	imagerel $unwind$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateBackInit_ DD imagerel $LN13+83
	DD	imagerel $LN13+192
	DD	imagerel $chain$1$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateBackInit_ DD imagerel $LN13+192
	DD	imagerel $LN13+225
	DD	imagerel $chain$3$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateBackInit_ DD imagerel $LN13+225
	DD	imagerel $LN13+267
	DD	imagerel $chain$4$inflateBackInit_
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateBackInit_ DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+83
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateBackInit_ DD 040021H
	DD	07e400H
	DD	067400H
	DD	imagerel $LN13
	DD	imagerel $LN13+83
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateBackInit_ DD 040a21H
	DD	07e40aH
	DD	067405H
	DD	imagerel $LN13
	DD	imagerel $LN13+83
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackInit_ DD 060f01H
	DD	09540fH
	DD	08340fH
	DD	0600b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateBack DD 021H
	DD	imagerel $LN494
	DD	imagerel $LN494+66
	DD	imagerel $unwind$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateBack DD 082221H
	DD	0be422H
	DD	0c741eH
	DD	0d6408H
	DD	0e3404H
	DD	imagerel $LN494
	DD	imagerel $LN494+66
	DD	imagerel $unwind$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBack DD 052101H
	DD	0f01ae221H
	DD	0c016d018H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackEnd DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File d:\projectsgit\gamecode4\source\gcc4\3rdparty\zlib-1.2.8\infback.c
;	COMDAT inflateBackInit_
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
window$ = 64
version$ = 72
stream_size$ = 80
inflateBackInit_ PROC					; COMDAT

; 34   : {

$LN13:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	56		 push	 rsi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b e8	 mov	 rbp, r8
  00012	8b f2		 mov	 esi, edx
  00014	48 8b d9	 mov	 rbx, rcx

; 35   :     struct inflate_state FAR *state;
; 36   : 
; 37   :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 38   :         stream_size != (int)(sizeof(z_stream)))

  00017	4d 85 c9	 test	 r9, r9
  0001a	0f 84 d6 00 00
	00		 je	 $LN6@inflateBac
  00020	41 80 39 31	 cmp	 BYTE PTR [r9], 49	; 00000031H
  00024	0f 85 cc 00 00
	00		 jne	 $LN6@inflateBac
  0002a	83 7c 24 50 58	 cmp	 DWORD PTR stream_size$[rsp], 88 ; 00000058H
  0002f	0f 85 c1 00 00
	00		 jne	 $LN6@inflateBac

; 39   :         return Z_VERSION_ERROR;
; 40   :     if (strm == Z_NULL || window == Z_NULL ||
; 41   :         windowBits < 8 || windowBits > 15)

  00035	48 85 c9	 test	 rcx, rcx
  00038	0f 84 a3 00 00
	00		 je	 $LN4@inflateBac
  0003e	4d 85 c0	 test	 r8, r8
  00041	0f 84 9a 00 00
	00		 je	 $LN4@inflateBac
  00047	8d 42 f8	 lea	 eax, DWORD PTR [rdx-8]
  0004a	83 f8 07	 cmp	 eax, 7
  0004d	0f 87 8e 00 00
	00		 ja	 $LN4@inflateBac

; 43   :     strm->msg = Z_NULL;                 /* in case we return an error */

  00053	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00058	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  0005d	45 33 f6	 xor	 r14d, r14d
  00060	4c 89 71 20	 mov	 QWORD PTR [rcx+32], r14

; 44   :     if (strm->zalloc == (alloc_func)0) {

  00064	4c 39 71 30	 cmp	 QWORD PTR [rcx+48], r14
  00068	75 0f		 jne	 SHORT $LN3@inflateBac

; 45   : #ifdef Z_SOLO
; 46   :         return Z_STREAM_ERROR;
; 47   : #else
; 48   :         strm->zalloc = zcalloc;

  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc

; 49   :         strm->opaque = (voidpf)0;

  00071	4c 89 71 40	 mov	 QWORD PTR [rcx+64], r14
  00075	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
$LN3@inflateBac:

; 50   : #endif
; 51   :     }
; 52   :     if (strm->zfree == (free_func)0)

  00079	4c 39 71 38	 cmp	 QWORD PTR [rcx+56], r14
  0007d	75 0b		 jne	 SHORT $LN2@inflateBac

; 53   : #ifdef Z_SOLO
; 54   :         return Z_STREAM_ERROR;
; 55   : #else
; 56   :     strm->zfree = zcfree;

  0007f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcfree
  00086	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN2@inflateBac:

; 57   : #endif
; 58   :     state = (struct inflate_state FAR *)ZALLOC(strm, 1,
; 59   :                                                sizeof(struct inflate_state));

  0008a	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0008e	bf 01 00 00 00	 mov	 edi, 1
  00093	41 b8 e8 1b 00
	00		 mov	 r8d, 7144		; 00001be8H
  00099	8b d7		 mov	 edx, edi
  0009b	ff 53 30	 call	 QWORD PTR [rbx+48]

; 60   :     if (state == Z_NULL) return Z_MEM_ERROR;

  0009e	48 85 c0	 test	 rax, rax
  000a1	75 1d		 jne	 SHORT $LN1@inflateBac
  000a3	8d 47 fb	 lea	 eax, QWORD PTR [rdi-5]
$LN11@inflateBac:
  000a6	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  000ab	4c 8b 74 24 38	 mov	 r14, QWORD PTR [rsp+56]

; 70   : }

  000b0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b5	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000ba	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000be	5e		 pop	 rsi
  000bf	c3		 ret	 0
$LN1@inflateBac:

; 61   :     Tracev((stderr, "inflate: allocated\n"));
; 62   :     strm->state = (struct internal_state FAR *)state;

  000c0	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax

; 63   :     state->dmax = 32768U;
; 64   :     state->wbits = windowBits;
; 65   :     state->wsize = 1U << windowBits;

  000c4	8b ce		 mov	 ecx, esi
  000c6	c7 40 14 00 80
	00 00		 mov	 DWORD PTR [rax+20], 32768 ; 00008000H
  000cd	d3 e7		 shl	 edi, cl
  000cf	89 70 28	 mov	 DWORD PTR [rax+40], esi

; 66   :     state->window = window;

  000d2	48 89 68 38	 mov	 QWORD PTR [rax+56], rbp
  000d6	89 78 2c	 mov	 DWORD PTR [rax+44], edi

; 67   :     state->wnext = 0;
; 68   :     state->whave = 0;

  000d9	4c 89 70 30	 mov	 QWORD PTR [rax+48], r14

; 69   :     return Z_OK;

  000dd	33 c0		 xor	 eax, eax
  000df	eb c5		 jmp	 SHORT $LN11@inflateBac
$LN4@inflateBac:

; 42   :         return Z_STREAM_ERROR;

  000e1	b8 fe ff ff ff	 mov	 eax, -2

; 70   : }

  000e6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000eb	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000f0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f4	5e		 pop	 rsi
  000f5	c3		 ret	 0
$LN6@inflateBac:
  000f6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000fb	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00100	b8 fa ff ff ff	 mov	 eax, -6
  00105	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00109	5e		 pop	 rsi
  0010a	c3		 ret	 0
inflateBackInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\projectsgit\gamecode4\source\gcc4\3rdparty\zlib-1.2.8\infback.c
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 8
fixedtables PROC					; COMDAT

; 85   : #ifdef BUILDFIXED
; 86   :     static int virgin = 1;
; 87   :     static code *lenfix, *distfix;
; 88   :     static code fixed[544];
; 89   : 
; 90   :     /* build fixed huffman tables if first call (may not be thread safe) */
; 91   :     if (virgin) {
; 92   :         unsigned sym, bits;
; 93   :         static code *next;
; 94   : 
; 95   :         /* literal/length table */
; 96   :         sym = 0;
; 97   :         while (sym < 144) state->lens[sym++] = 8;
; 98   :         while (sym < 256) state->lens[sym++] = 9;
; 99   :         while (sym < 280) state->lens[sym++] = 7;
; 100  :         while (sym < 288) state->lens[sym++] = 8;
; 101  :         next = fixed;
; 102  :         lenfix = next;
; 103  :         bits = 9;
; 104  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 105  : 
; 106  :         /* distance table */
; 107  :         sym = 0;
; 108  :         while (sym < 32) state->lens[sym++] = 5;
; 109  :         distfix = next;
; 110  :         bits = 5;
; 111  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 112  : 
; 113  :         /* do this just once */
; 114  :         virgin = 0;
; 115  :     }
; 116  : #else /* !BUILDFIXED */
; 117  : #   include "inffixed.h"
; 118  : #endif /* BUILDFIXED */
; 119  :     state->lencode = lenfix;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9

; 120  :     state->lenbits = 9;

  00007	c7 41 68 09 00
	00 00		 mov	 DWORD PTR [rcx+104], 9

; 121  :     state->distcode = distfix;
; 122  :     state->distbits = 5;

  0000e	c7 41 6c 05 00
	00 00		 mov	 DWORD PTR [rcx+108], 5
  00015	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax
  00019	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  00020	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 123  : }

  00024	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\projectsgit\gamecode4\source\gcc4\3rdparty\zlib-1.2.8\infback.c
;	COMDAT inflateBack
_TEXT	SEGMENT
left$1$ = 48
last$ = 52
here$ = 52
next$ = 56
put$1$ = 64
strm$ = 160
in$ = 168
in_desc$ = 176
out$ = 184
out_desc$ = 192
inflateBack PROC					; COMDAT

; 256  : {

$LN494:
  00000	48 8b c4	 mov	 rax, rsp
  00003	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  00007	4c 89 40 18	 mov	 QWORD PTR [rax+24], r8
  0000b	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx
  0000f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00013	55		 push	 rbp
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 57		 push	 r15
  0001a	48 8b ec	 mov	 rbp, rsp
  0001d	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00021	4d 8b e0	 mov	 r12, r8
  00024	4c 8b ea	 mov	 r13, rdx
  00027	4c 8b c1	 mov	 r8, rcx

; 257  :     struct inflate_state FAR *state;
; 258  :     z_const unsigned char FAR *next;    /* next input */
; 259  :     unsigned char FAR *put;     /* next output */
; 260  :     unsigned have, left;        /* available input and output */
; 261  :     unsigned long hold;         /* bit buffer */
; 262  :     unsigned bits;              /* bits in bit buffer */
; 263  :     unsigned copy;              /* number of stored or match bytes to copy */
; 264  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 265  :     code here;                  /* current decoding table entry */
; 266  :     code last;                  /* parent table entry */
; 267  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 268  :     int ret;                    /* return code */
; 269  :     static const unsigned short order[19] = /* permutation of code lengths */
; 270  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 271  : 
; 272  :     /* Check that the strm exists and that the state was initialized */
; 273  :     if (strm == Z_NULL || strm->state == Z_NULL)

  0002a	48 85 c9	 test	 rcx, rcx
  0002d	0f 84 3d 0e 00
	00		 je	 $LN333@inflateBac
  00033	4c 8b 79 28	 mov	 r15, QWORD PTR [rcx+40]
  00037	4d 85 ff	 test	 r15, r15
  0003a	0f 84 30 0e 00
	00		 je	 $LN333@inflateBac

; 275  :     state = (struct inflate_state FAR *)strm->state;
; 276  : 
; 277  :     /* Reset the state */
; 278  :     strm->msg = Z_NULL;

  00040	33 d2		 xor	 edx, edx
  00042	48 89 58 d8	 mov	 QWORD PTR [rax-40], rbx
  00046	48 89 70 d0	 mov	 QWORD PTR [rax-48], rsi
  0004a	48 89 51 20	 mov	 QWORD PTR [rcx+32], rdx

; 279  :     state->mode = TYPE;

  0004e	49 c7 07 0b 00
	00 00		 mov	 QWORD PTR [r15], 11

; 280  :     state->last = 0;
; 281  :     state->whave = 0;

  00055	41 89 57 30	 mov	 DWORD PTR [r15+48], edx

; 282  :     next = strm->next_in;

  00059	4c 8b 11	 mov	 r10, QWORD PTR [rcx]
  0005c	48 89 78 c8	 mov	 QWORD PTR [rax-56], rdi
  00060	4c 89 70 c0	 mov	 QWORD PTR [rax-64], r14
  00064	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10

; 283  :     have = next != Z_NULL ? strm->avail_in : 0;

  00068	4d 85 d2	 test	 r10, r10
  0006b	74 05		 je	 SHORT $LN337@inflateBac
  0006d	8b 79 08	 mov	 edi, DWORD PTR [rcx+8]
  00070	eb 02		 jmp	 SHORT $LN338@inflateBac
$LN337@inflateBac:
  00072	8b fa		 mov	 edi, edx
$LN338@inflateBac:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;
; 287  :     left = state->wsize;
; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  00074	41 8b 07	 mov	 eax, DWORD PTR [r15]
  00077	49 8b 5f 38	 mov	 rbx, QWORD PTR [r15+56]
  0007b	45 8b 4f 2c	 mov	 r9d, DWORD PTR [r15+44]
  0007f	83 e8 0b	 sub	 eax, 11
  00082	44 8b f2	 mov	 r14d, edx
  00085	8b f2		 mov	 esi, edx
  00087	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  0008b	44 89 4d b8	 mov	 DWORD PTR left$1$[rbp-120], r9d
  0008f	83 f8 12	 cmp	 eax, 18
  00092	0f 87 a5 0d 00
	00		 ja	 $LN1@inflateBac
$LN488@inflateBac:
  00098	48 98		 cdqe
  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000a1	41 bb 01 00 00
	00		 mov	 r11d, 1
  000a7	8b 8c 81 00 00
	00 00		 mov	 ecx, DWORD PTR $LN467@inflateBac[rcx+rax*4]
  000ae	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:__ImageBase
  000b5	48 03 c8	 add	 rcx, rax
  000b8	ff e1		 jmp	 rcx
$LN328@inflateBac:

; 292  :         case TYPE:
; 293  :             /* determine and dispatch block type */
; 294  :             if (state->last) {

  000ba	41 83 7f 04 00	 cmp	 DWORD PTR [r15+4], 0
  000bf	74 1a		 je	 SHORT $LN323@inflateBac

; 295  :                 BYTEBITS();

  000c1	8b ce		 mov	 ecx, esi

; 296  :                 state->mode = DONE;

  000c3	41 c7 07 1c 00
	00 00		 mov	 DWORD PTR [r15], 28

; 297  :                 break;

  000ca	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  000ce	83 e1 07	 and	 ecx, 7
  000d1	41 d3 ee	 shr	 r14d, cl
  000d4	2b f1		 sub	 esi, ecx
  000d6	e9 cb 09 00 00	 jmp	 $LN387@inflateBac
$LN323@inflateBac:

; 298  :             }
; 299  :             NEEDBITS(3);

  000db	83 fe 03	 cmp	 esi, 3
  000de	73 42		 jae	 SHORT $LN322@inflateBac
$LL320@inflateBac:
  000e0	85 ff		 test	 edi, edi
  000e2	75 18		 jne	 SHORT $LN314@inflateBac
  000e4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  000e8	49 8b cc	 mov	 rcx, r12
  000eb	41 ff d5	 call	 r13
  000ee	8b f8		 mov	 edi, eax
  000f0	85 c0		 test	 eax, eax
  000f2	0f 84 0d 0d 00
	00		 je	 $LN363@inflateBac
  000f8	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN314@inflateBac:
  000fc	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00100	8b ce		 mov	 ecx, esi
  00102	49 ff c2	 inc	 r10
  00105	d3 e0		 shl	 eax, cl
  00107	83 c6 08	 add	 esi, 8
  0010a	ff cf		 dec	 edi
  0010c	44 03 f0	 add	 r14d, eax
  0010f	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00113	83 fe 03	 cmp	 esi, 3
  00116	72 c8		 jb	 SHORT $LL320@inflateBac
  00118	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  0011c	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
  00120	33 d2		 xor	 edx, edx
$LN322@inflateBac:

; 300  :             state->last = BITS(1);

  00122	41 8b c6	 mov	 eax, r14d

; 301  :             DROPBITS(1);

  00125	41 d1 ee	 shr	 r14d, 1
  00128	ff ce		 dec	 esi
  0012a	83 e0 01	 and	 eax, 1
  0012d	41 89 47 04	 mov	 DWORD PTR [r15+4], eax

; 302  :             switch (BITS(2)) {

  00131	41 8b c6	 mov	 eax, r14d
  00134	83 e0 03	 and	 eax, 3
  00137	74 64		 je	 SHORT $LN305@inflateBac
  00139	ff c8		 dec	 eax
  0013b	74 41		 je	 SHORT $LN304@inflateBac
  0013d	ff c8		 dec	 eax
  0013f	74 26		 je	 SHORT $LN303@inflateBac
  00141	ff c8		 dec	 eax
  00143	75 5f		 jne	 SHORT $LN301@inflateBac

; 318  :                 break;
; 319  :             case 3:
; 320  :                 strm->msg = (char *)"invalid block type";

  00145	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 321  :                 state->mode = BAD;
; 322  :             }
; 323  :             DROPBITS(2);

  0014c	41 c1 ee 02	 shr	 r14d, 2
  00150	83 c6 fe	 add	 esi, -2			; fffffffeH
  00153	49 89 40 20	 mov	 QWORD PTR [r8+32], rax
  00157	41 c7 07 1d 00
	00 00		 mov	 DWORD PTR [r15], 29

; 324  :             break;

  0015e	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00162	e9 3f 09 00 00	 jmp	 $LN387@inflateBac
$LN303@inflateBac:

; 313  :                 break;
; 314  :             case 2:                             /* dynamic block */
; 315  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 316  :                         state->last ? " (last)" : ""));
; 317  :                 state->mode = TABLE;

  00167	41 c7 07 10 00
	00 00		 mov	 DWORD PTR [r15], 16

; 324  :             break;

  0016e	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00172	41 c1 ee 02	 shr	 r14d, 2
  00176	83 c6 fe	 add	 esi, -2			; fffffffeH
  00179	e9 28 09 00 00	 jmp	 $LN387@inflateBac
$LN304@inflateBac:

; 307  :                 break;
; 308  :             case 1:                             /* fixed block */
; 309  :                 fixedtables(state);

  0017e	49 8b cf	 mov	 rcx, r15
  00181	e8 00 00 00 00	 call	 fixedtables

; 310  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 311  :                         state->last ? " (last)" : ""));
; 312  :                 state->mode = LEN;              /* decode codes */

  00186	41 c7 07 14 00
	00 00		 mov	 DWORD PTR [r15], 20

; 324  :             break;

  0018d	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00191	41 c1 ee 02	 shr	 r14d, 2
  00195	83 c6 fe	 add	 esi, -2			; fffffffeH
  00198	e9 09 09 00 00	 jmp	 $LN387@inflateBac
$LN305@inflateBac:

; 303  :             case 0:                             /* stored block */
; 304  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 305  :                         state->last ? " (last)" : ""));
; 306  :                 state->mode = STORED;

  0019d	41 c7 07 0d 00
	00 00		 mov	 DWORD PTR [r15], 13
$LN301@inflateBac:

; 324  :             break;

  001a4	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  001a8	41 c1 ee 02	 shr	 r14d, 2
  001ac	83 c6 fe	 add	 esi, -2			; fffffffeH
  001af	e9 f2 08 00 00	 jmp	 $LN387@inflateBac
$LN297@inflateBac:

; 325  : 
; 326  :         case STORED:
; 327  :             /* get and verify stored block length */
; 328  :             BYTEBITS();                         /* go to byte boundary */

  001b4	8b ce		 mov	 ecx, esi
  001b6	83 e1 07	 and	 ecx, 7
  001b9	2b f1		 sub	 esi, ecx
  001bb	41 d3 ee	 shr	 r14d, cl

; 329  :             NEEDBITS(32);

  001be	83 fe 20	 cmp	 esi, 32			; 00000020H
  001c1	73 42		 jae	 SHORT $LN293@inflateBac
$LL291@inflateBac:
  001c3	85 ff		 test	 edi, edi
  001c5	75 18		 jne	 SHORT $LN285@inflateBac
  001c7	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  001cb	49 8b cc	 mov	 rcx, r12
  001ce	41 ff d5	 call	 r13
  001d1	8b f8		 mov	 edi, eax
  001d3	85 c0		 test	 eax, eax
  001d5	0f 84 2a 0c 00
	00		 je	 $LN363@inflateBac
  001db	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN285@inflateBac:
  001df	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  001e3	8b ce		 mov	 ecx, esi
  001e5	49 ff c2	 inc	 r10
  001e8	d3 e0		 shl	 eax, cl
  001ea	83 c6 08	 add	 esi, 8
  001ed	ff cf		 dec	 edi
  001ef	44 03 f0	 add	 r14d, eax
  001f2	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  001f6	83 fe 20	 cmp	 esi, 32			; 00000020H
  001f9	72 c8		 jb	 SHORT $LL291@inflateBac
  001fb	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  001ff	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
  00203	33 d2		 xor	 edx, edx
$LN293@inflateBac:

; 330  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  00205	41 8b c6	 mov	 eax, r14d
  00208	41 0f b7 ce	 movzx	 ecx, r14w
  0020c	f7 d0		 not	 eax
  0020e	c1 e8 10	 shr	 eax, 16
  00211	3b c8		 cmp	 ecx, eax
  00213	74 1b		 je	 SHORT $LN281@inflateBac

; 331  :                 strm->msg = (char *)"invalid stored block lengths";

  00215	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
  0021c	49 89 40 20	 mov	 QWORD PTR [r8+32], rax

; 332  :                 state->mode = BAD;

  00220	41 c7 07 1d 00
	00 00		 mov	 DWORD PTR [r15], 29

; 333  :                 break;

  00227	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  0022b	e9 76 08 00 00	 jmp	 $LN387@inflateBac
$LN281@inflateBac:

; 334  :             }
; 335  :             state->length = (unsigned)hold & 0xffff;

  00230	41 89 4f 48	 mov	 DWORD PTR [r15+72], ecx

; 336  :             Tracev((stderr, "inflate:       stored length %u\n",
; 337  :                     state->length));
; 338  :             INITBITS();

  00234	44 8b f2	 mov	 r14d, edx
  00237	8b f2		 mov	 esi, edx

; 339  : 
; 340  :             /* copy stored block from input to output */
; 341  :             while (state->length != 0) {

  00239	85 c9		 test	 ecx, ecx
  0023b	0f 84 96 00 00
	00		 je	 $LN276@inflateBac
  00241	4c 8b 6d 38	 mov	 r13, QWORD PTR in_desc$[rbp-120]
$LL277@inflateBac:

; 342  :                 copy = state->length;

  00245	45 8b 67 48	 mov	 r12d, DWORD PTR [r15+72]

; 343  :                 PULL();

  00249	85 ff		 test	 edi, edi
  0024b	75 14		 jne	 SHORT $LN274@inflateBac
  0024d	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00251	49 8b cd	 mov	 rcx, r13
  00254	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00257	8b f8		 mov	 edi, eax
  00259	85 c0		 test	 eax, eax
  0025b	0f 84 a4 0b 00
	00		 je	 $LN363@inflateBac
$LN274@inflateBac:

; 344  :                 ROOM();

  00261	8b 5d b8	 mov	 ebx, DWORD PTR left$1$[rbp-120]
  00264	85 db		 test	 ebx, ebx
  00266	75 28		 jne	 SHORT $LN269@inflateBac
  00268	41 8b 5f 2c	 mov	 ebx, DWORD PTR [r15+44]
  0026c	49 8b 47 38	 mov	 rax, QWORD PTR [r15+56]
  00270	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00274	44 8b c3	 mov	 r8d, ebx
  00277	48 8b d0	 mov	 rdx, rax
  0027a	48 89 45 c8	 mov	 QWORD PTR put$1$[rbp-120], rax
  0027e	89 5d b8	 mov	 DWORD PTR left$1$[rbp-120], ebx
  00281	41 89 5f 30	 mov	 DWORD PTR [r15+48], ebx
  00285	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00288	85 c0		 test	 eax, eax
  0028a	0f 85 c0 07 00
	00		 jne	 $LN366@inflateBac
$LN269@inflateBac:

; 345  :                 if (copy > have) copy = have;
; 346  :                 if (copy > left) copy = left;
; 347  :                 zmemcpy(put, next, copy);

  00290	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  00294	48 8b 4d c8	 mov	 rcx, QWORD PTR put$1$[rbp-120]
  00298	44 3b e7	 cmp	 r12d, edi
  0029b	44 0f 47 e7	 cmova	 r12d, edi
  0029f	44 3b e3	 cmp	 r12d, ebx
  002a2	44 0f 47 e3	 cmova	 r12d, ebx
  002a6	45 8b c4	 mov	 r8d, r12d
  002a9	41 8b dc	 mov	 ebx, r12d
  002ac	e8 00 00 00 00	 call	 memcpy

; 348  :                 have -= copy;
; 349  :                 next += copy;
; 350  :                 left -= copy;

  002b1	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  002b5	48 01 5d c0	 add	 QWORD PTR next$[rbp-120], rbx

; 351  :                 put += copy;

  002b9	48 01 5d c8	 add	 QWORD PTR put$1$[rbp-120], rbx
  002bd	45 2b cc	 sub	 r9d, r12d
  002c0	41 2b fc	 sub	 edi, r12d

; 352  :                 state->length -= copy;

  002c3	45 29 67 48	 sub	 DWORD PTR [r15+72], r12d
  002c7	44 89 4d b8	 mov	 DWORD PTR left$1$[rbp-120], r9d
  002cb	0f 85 74 ff ff
	ff		 jne	 $LL277@inflateBac
  002d1	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  002d5	33 d2		 xor	 edx, edx
$LN276@inflateBac:

; 353  :             }
; 354  :             Tracev((stderr, "inflate:       stored end\n"));
; 355  :             state->mode = TYPE;

  002d7	41 c7 07 0b 00
	00 00		 mov	 DWORD PTR [r15], 11

; 356  :             break;

  002de	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  002e2	e9 bb 07 00 00	 jmp	 $LN481@inflateBac
$LN262@inflateBac:

; 357  : 
; 358  :         case TABLE:
; 359  :             /* get dynamic table entries descriptor */
; 360  :             NEEDBITS(14);

  002e7	83 fe 0e	 cmp	 esi, 14
  002ea	73 44		 jae	 SHORT $LN261@inflateBac
  002ec	0f 1f 40 00	 npad	 4
$LL259@inflateBac:
  002f0	85 ff		 test	 edi, edi
  002f2	75 18		 jne	 SHORT $LN253@inflateBac
  002f4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  002f8	49 8b cc	 mov	 rcx, r12
  002fb	41 ff d5	 call	 r13
  002fe	8b f8		 mov	 edi, eax
  00300	85 c0		 test	 eax, eax
  00302	0f 84 fd 0a 00
	00		 je	 $LN363@inflateBac
  00308	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN253@inflateBac:
  0030c	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00310	8b ce		 mov	 ecx, esi
  00312	49 ff c2	 inc	 r10
  00315	d3 e0		 shl	 eax, cl
  00317	83 c6 08	 add	 esi, 8
  0031a	ff cf		 dec	 edi
  0031c	44 03 f0	 add	 r14d, eax
  0031f	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00323	83 fe 0e	 cmp	 esi, 14
  00326	72 c8		 jb	 SHORT $LL259@inflateBac
  00328	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  0032c	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
$LN261@inflateBac:

; 361  :             state->nlen = BITS(5) + 257;

  00330	41 8b c6	 mov	 eax, r14d

; 362  :             DROPBITS(5);

  00333	41 c1 ee 05	 shr	 r14d, 5

; 363  :             state->ndist = BITS(5) + 1;
; 364  :             DROPBITS(5);
; 365  :             state->ncode = BITS(4) + 4;
; 366  :             DROPBITS(4);

  00337	83 c6 f2	 add	 esi, -14		; fffffff2H
  0033a	41 8b ce	 mov	 ecx, r14d
  0033d	41 c1 ee 05	 shr	 r14d, 5
  00341	83 e0 1f	 and	 eax, 31
  00344	41 8b d6	 mov	 edx, r14d
  00347	83 e1 1f	 and	 ecx, 31
  0034a	05 01 01 00 00	 add	 eax, 257		; 00000101H
  0034f	83 e2 0f	 and	 edx, 15
  00352	ff c1		 inc	 ecx
  00354	41 c1 ee 04	 shr	 r14d, 4
  00358	83 c2 04	 add	 edx, 4
  0035b	41 89 47 74	 mov	 DWORD PTR [r15+116], eax
  0035f	41 89 4f 78	 mov	 DWORD PTR [r15+120], ecx
  00363	41 89 57 70	 mov	 DWORD PTR [r15+112], edx

; 367  : #ifndef PKZIP_BUG_WORKAROUND
; 368  :             if (state->nlen > 286 || state->ndist > 30) {

  00367	3d 1e 01 00 00	 cmp	 eax, 286		; 0000011eH
  0036c	0f 87 22 05 00
	00		 ja	 $LN239@inflateBac
  00372	83 f9 1e	 cmp	 ecx, 30
  00375	0f 87 19 05 00
	00		 ja	 $LN239@inflateBac

; 372  :             }
; 373  : #endif
; 374  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 375  : 
; 376  :             /* get code length code lengths (not a typo) */
; 377  :             state->have = 0;

  0037b	33 c9		 xor	 ecx, ecx

; 378  :             while (state->have < state->ncode) {

  0037d	85 d2		 test	 edx, edx
  0037f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00386	41 89 4f 7c	 mov	 DWORD PTR [r15+124], ecx
  0038a	0f 84 82 00 00
	00		 je	 $LN346@inflateBac
$LL238@inflateBac:

; 379  :                 NEEDBITS(3);

  00390	83 fe 03	 cmp	 esi, 3
  00393	73 49		 jae	 SHORT $LN235@inflateBac
  00395	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  00399	0f 1f 80 00 00
	00 00		 npad	 7
$LL233@inflateBac:
  003a0	85 ff		 test	 edi, edi
  003a2	75 18		 jne	 SHORT $LN227@inflateBac
  003a4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  003a8	49 8b cc	 mov	 rcx, r12
  003ab	41 ff d5	 call	 r13
  003ae	8b f8		 mov	 edi, eax
  003b0	85 c0		 test	 eax, eax
  003b2	0f 84 4d 0a 00
	00		 je	 $LN363@inflateBac
  003b8	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN227@inflateBac:
  003bc	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  003bf	8b ce		 mov	 ecx, esi
  003c1	48 ff c2	 inc	 rdx
  003c4	d3 e0		 shl	 eax, cl
  003c6	83 c6 08	 add	 esi, 8
  003c9	ff cf		 dec	 edi
  003cb	44 03 f0	 add	 r14d, eax
  003ce	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  003d2	83 fe 03	 cmp	 esi, 3
  003d5	72 c9		 jb	 SHORT $LL233@inflateBac
  003d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
$LN235@inflateBac:

; 380  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  003de	41 8b 47 7c	 mov	 eax, DWORD PTR [r15+124]
  003e2	41 0f b7 ce	 movzx	 ecx, r14w

; 381  :                 DROPBITS(3);

  003e6	83 c6 fd	 add	 esi, -3			; fffffffdH
  003e9	0f b7 84 42 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[rdx+rax*2]
  003f1	66 83 e1 07	 and	 cx, 7
  003f5	41 c1 ee 03	 shr	 r14d, 3
  003f9	66 41 89 8c 47
	88 00 00 00	 mov	 WORD PTR [r15+rax*2+136], cx
  00402	41 ff 47 7c	 inc	 DWORD PTR [r15+124]
  00406	41 8b 47 7c	 mov	 eax, DWORD PTR [r15+124]
  0040a	41 3b 47 70	 cmp	 eax, DWORD PTR [r15+112]
  0040e	72 80		 jb	 SHORT $LL238@inflateBac
  00410	33 c9		 xor	 ecx, ecx
$LN346@inflateBac:

; 382  :             }
; 383  :             while (state->have < 19)

  00412	41 83 7f 7c 13	 cmp	 DWORD PTR [r15+124], 19
  00417	73 27		 jae	 SHORT $LN219@inflateBac
  00419	0f 1f 80 00 00
	00 00		 npad	 7
$LL220@inflateBac:

; 384  :                 state->lens[order[state->have++]] = 0;

  00420	41 8b 47 7c	 mov	 eax, DWORD PTR [r15+124]
  00424	0f b7 84 42 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[rdx+rax*2]
  0042c	66 41 89 8c 47
	88 00 00 00	 mov	 WORD PTR [r15+rax*2+136], cx
  00435	41 ff 47 7c	 inc	 DWORD PTR [r15+124]
  00439	41 83 7f 7c 13	 cmp	 DWORD PTR [r15+124], 19
  0043e	72 e0		 jb	 SHORT $LL220@inflateBac
$LN219@inflateBac:

; 385  :             state->next = state->codes;

  00440	49 8d 87 48 05
	00 00		 lea	 rax, QWORD PTR [r15+1352]

; 386  :             state->lencode = (code const FAR *)(state->next);
; 387  :             state->lenbits = 7;
; 388  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 389  :                                 &(state->lenbits), state->work);

  00447	49 8d 97 08 03
	00 00		 lea	 rdx, QWORD PTR [r15+776]
  0044e	4d 8d 8f 80 00
	00 00		 lea	 r9, QWORD PTR [r15+128]
  00455	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  0045a	49 89 87 80 00
	00 00		 mov	 QWORD PTR [r15+128], rax
  00461	49 89 47 58	 mov	 QWORD PTR [r15+88], rax
  00465	49 8d 47 68	 lea	 rax, QWORD PTR [r15+104]
  00469	49 8d 97 88 00
	00 00		 lea	 rdx, QWORD PTR [r15+136]
  00470	41 b8 13 00 00
	00		 mov	 r8d, 19
  00476	33 c9		 xor	 ecx, ecx
  00478	c7 00 07 00 00
	00		 mov	 DWORD PTR [rax], 7
  0047e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00483	e8 00 00 00 00	 call	 inflate_table

; 390  :             if (ret) {

  00488	85 c0		 test	 eax, eax
  0048a	74 25		 je	 SHORT $LN218@inflateBac

; 391  :                 strm->msg = (char *)"invalid code lengths set";

  0048c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
$LN490@inflateBac:
  00493	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]

; 392  :                 state->mode = BAD;
; 393  :                 break;

  00497	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  0049b	33 d2		 xor	 edx, edx
  0049d	49 89 40 20	 mov	 QWORD PTR [r8+32], rax
  004a1	41 c7 07 1d 00
	00 00		 mov	 DWORD PTR [r15], 29
  004a8	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  004ac	e9 f5 05 00 00	 jmp	 $LN387@inflateBac
$LN218@inflateBac:

; 394  :             }
; 395  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 396  : 
; 397  :             /* get length and distance code code lengths */
; 398  :             state->have = 0;
; 399  :             while (state->have < state->nlen + state->ndist) {

  004b1	41 8b 47 78	 mov	 eax, DWORD PTR [r15+120]
  004b5	41 c7 47 7c 00
	00 00 00	 mov	 DWORD PTR [r15+124], 0
  004bd	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  004c1	41 03 47 74	 add	 eax, DWORD PTR [r15+116]
  004c5	0f 84 59 02 00
	00		 je	 $LN216@inflateBac
  004cb	49 8d 5f 68	 lea	 rbx, QWORD PTR [r15+104]
  004cf	90		 npad	 1
$LL217@inflateBac:

; 400  :                 for (;;) {
; 401  :                     here = state->lencode[BITS(state->lenbits)];

  004d0	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  004d2	b8 01 00 00 00	 mov	 eax, 1
  004d7	d3 e0		 shl	 eax, cl
  004d9	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  004dc	41 8b c6	 mov	 eax, r14d
  004df	48 23 c8	 and	 rcx, rax
  004e2	49 8b 47 58	 mov	 rax, QWORD PTR [r15+88]
  004e6	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]

; 402  :                     if ((unsigned)(here.bits) <= bits) break;

  004e9	8b c8		 mov	 ecx, eax
  004eb	89 45 bc	 mov	 DWORD PTR here$[rbp-120], eax
  004ee	c1 e9 08	 shr	 ecx, 8
  004f1	0f b6 c9	 movzx	 ecx, cl
  004f4	3b ce		 cmp	 ecx, esi
  004f6	76 5b		 jbe	 SHORT $LN369@inflateBac
$LL215@inflateBac:

; 403  :                     PULLBYTE();

  004f8	85 ff		 test	 edi, edi
  004fa	75 18		 jne	 SHORT $LN208@inflateBac
  004fc	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00500	49 8b cc	 mov	 rcx, r12
  00503	41 ff d5	 call	 r13
  00506	8b f8		 mov	 edi, eax
  00508	85 c0		 test	 eax, eax
  0050a	0f 84 f5 08 00
	00		 je	 $LN363@inflateBac
  00510	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN208@inflateBac:
  00514	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00518	8b ce		 mov	 ecx, esi
  0051a	49 ff c2	 inc	 r10
  0051d	d3 e0		 shl	 eax, cl
  0051f	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00523	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00525	44 03 f0	 add	 r14d, eax
  00528	b8 01 00 00 00	 mov	 eax, 1
  0052d	83 c6 08	 add	 esi, 8
  00530	d3 e0		 shl	 eax, cl
  00532	ff cf		 dec	 edi
  00534	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00537	41 8b c6	 mov	 eax, r14d
  0053a	48 23 c8	 and	 rcx, rax
  0053d	49 8b 47 58	 mov	 rax, QWORD PTR [r15+88]
  00541	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00544	8b c8		 mov	 ecx, eax
  00546	89 45 bc	 mov	 DWORD PTR here$[rbp-120], eax
  00549	c1 e9 08	 shr	 ecx, 8
  0054c	0f b6 c9	 movzx	 ecx, cl
  0054f	3b ce		 cmp	 ecx, esi
  00551	77 a5		 ja	 SHORT $LL215@inflateBac
$LN369@inflateBac:

; 404  :                 }
; 405  :                 if (here.val < 16) {

  00553	8b d0		 mov	 edx, eax
  00555	c1 ea 10	 shr	 edx, 16
  00558	66 83 fa 10	 cmp	 dx, 16
  0055c	73 25		 jae	 SHORT $LN482@inflateBac

; 406  :                     DROPBITS(here.bits);

  0055e	c1 e8 08	 shr	 eax, 8
  00561	0f b6 c8	 movzx	 ecx, al

; 407  :                     state->lens[state->have++] = here.val;

  00564	41 8b 47 7c	 mov	 eax, DWORD PTR [r15+124]
  00568	66 41 89 94 47
	88 00 00 00	 mov	 WORD PTR [r15+rax*2+136], dx
  00571	41 d3 ee	 shr	 r14d, cl
  00574	2b f1		 sub	 esi, ecx
  00576	41 ff 47 7c	 inc	 DWORD PTR [r15+124]

; 408  :                 }
; 409  :                 else {

  0057a	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  0057e	e9 8b 01 00 00	 jmp	 $LN400@inflateBac
$LN482@inflateBac:

; 410  :                     if (here.val == 16) {

  00583	75 7b		 jne	 SHORT $LN199@inflateBac

; 411  :                         NEEDBITS(here.bits + 2);

  00585	c1 e8 08	 shr	 eax, 8
  00588	0f b6 d8	 movzx	 ebx, al
  0058b	83 c3 02	 add	 ebx, 2
  0058e	3b f3		 cmp	 esi, ebx
  00590	73 37		 jae	 SHORT $LN197@inflateBac
$LL195@inflateBac:
  00592	85 ff		 test	 edi, edi
  00594	75 18		 jne	 SHORT $LN189@inflateBac
  00596	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  0059a	49 8b cc	 mov	 rcx, r12
  0059d	41 ff d5	 call	 r13
  005a0	8b f8		 mov	 edi, eax
  005a2	85 c0		 test	 eax, eax
  005a4	0f 84 5b 08 00
	00		 je	 $LN363@inflateBac
  005aa	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN189@inflateBac:
  005ae	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  005b2	8b ce		 mov	 ecx, esi
  005b4	49 ff c2	 inc	 r10
  005b7	d3 e0		 shl	 eax, cl
  005b9	83 c6 08	 add	 esi, 8
  005bc	ff cf		 dec	 edi
  005be	44 03 f0	 add	 r14d, eax
  005c1	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  005c5	3b f3		 cmp	 esi, ebx
  005c7	72 c9		 jb	 SHORT $LL195@inflateBac
$LN197@inflateBac:

; 412  :                         DROPBITS(here.bits);

  005c9	0f b6 4d bd	 movzx	 ecx, BYTE PTR here$[rbp-119]

; 413  :                         if (state->have == 0) {

  005cd	41 8b 47 7c	 mov	 eax, DWORD PTR [r15+124]
  005d1	41 d3 ee	 shr	 r14d, cl
  005d4	2b f1		 sub	 esi, ecx
  005d6	85 c0		 test	 eax, eax
  005d8	0f 84 67 01 00
	00		 je	 $LN374@inflateBac

; 417  :                         }
; 418  :                         len = (unsigned)(state->lens[state->have - 1]);
; 419  :                         copy = 3 + BITS(2);

  005de	45 8b c6	 mov	 r8d, r14d
  005e1	ff c8		 dec	 eax

; 420  :                         DROPBITS(2);

  005e3	41 c1 ee 02	 shr	 r14d, 2
  005e7	45 0f b7 8c 47
	88 00 00 00	 movzx	 r9d, WORD PTR [r15+rax*2+136]
  005f0	41 83 e0 03	 and	 r8d, 3
  005f4	41 83 c0 03	 add	 r8d, 3
  005f8	83 c6 fe	 add	 esi, -2			; fffffffeH

; 421  :                     }
; 422  :                     else if (here.val == 17) {

  005fb	e9 cd 00 00 00	 jmp	 $LN138@inflateBac
$LN199@inflateBac:
  00600	66 83 7d be 11	 cmp	 WORD PTR here$[rbp-118], 17

; 423  :                         NEEDBITS(here.bits + 3);

  00605	44 0f b6 6d bd	 movzx	 r13d, BYTE PTR here$[rbp-119]
  0060a	75 5b		 jne	 SHORT $LN156@inflateBac
  0060c	41 8d 5d 03	 lea	 ebx, DWORD PTR [r13+3]
  00610	3b f3		 cmp	 esi, ebx
  00612	73 37		 jae	 SHORT $LN175@inflateBac
$LL173@inflateBac:
  00614	85 ff		 test	 edi, edi
  00616	75 18		 jne	 SHORT $LN167@inflateBac
  00618	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  0061c	49 8b cc	 mov	 rcx, r12
  0061f	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00622	8b f8		 mov	 edi, eax
  00624	85 c0		 test	 eax, eax
  00626	0f 84 d9 07 00
	00		 je	 $LN363@inflateBac
  0062c	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN167@inflateBac:
  00630	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00634	8b ce		 mov	 ecx, esi
  00636	49 ff c2	 inc	 r10
  00639	d3 e0		 shl	 eax, cl
  0063b	83 c6 08	 add	 esi, 8
  0063e	ff cf		 dec	 edi
  00640	44 03 f0	 add	 r14d, eax
  00643	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00647	3b f3		 cmp	 esi, ebx
  00649	72 c9		 jb	 SHORT $LL173@inflateBac
$LN175@inflateBac:

; 424  :                         DROPBITS(here.bits);

  0064b	41 8b cd	 mov	 ecx, r13d

; 425  :                         len = 0;
; 426  :                         copy = 3 + BITS(3);
; 427  :                         DROPBITS(3);

  0064e	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00653	41 d3 ee	 shr	 r14d, cl
  00656	45 8b c6	 mov	 r8d, r14d
  00659	41 83 e0 07	 and	 r8d, 7
  0065d	41 83 c0 03	 add	 r8d, 3
  00661	41 c1 ee 03	 shr	 r14d, 3

; 428  :                     }
; 429  :                     else {

  00665	eb 5a		 jmp	 SHORT $LN483@inflateBac
$LN156@inflateBac:

; 430  :                         NEEDBITS(here.bits + 7);

  00667	41 8d 5d 07	 lea	 ebx, DWORD PTR [r13+7]
  0066b	3b f3		 cmp	 esi, ebx
  0066d	73 38		 jae	 SHORT $LN155@inflateBac
  0066f	90		 npad	 1
$LL153@inflateBac:
  00670	85 ff		 test	 edi, edi
  00672	75 18		 jne	 SHORT $LN147@inflateBac
  00674	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00678	49 8b cc	 mov	 rcx, r12
  0067b	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  0067e	8b f8		 mov	 edi, eax
  00680	85 c0		 test	 eax, eax
  00682	0f 84 7d 07 00
	00		 je	 $LN363@inflateBac
  00688	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN147@inflateBac:
  0068c	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00690	8b ce		 mov	 ecx, esi
  00692	49 ff c2	 inc	 r10
  00695	d3 e0		 shl	 eax, cl
  00697	83 c6 08	 add	 esi, 8
  0069a	ff cf		 dec	 edi
  0069c	44 03 f0	 add	 r14d, eax
  0069f	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  006a3	3b f3		 cmp	 esi, ebx
  006a5	72 c9		 jb	 SHORT $LL153@inflateBac
$LN155@inflateBac:

; 431  :                         DROPBITS(here.bits);

  006a7	41 8b cd	 mov	 ecx, r13d

; 432  :                         len = 0;
; 433  :                         copy = 11 + BITS(7);
; 434  :                         DROPBITS(7);

  006aa	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
  006af	41 d3 ee	 shr	 r14d, cl
  006b2	45 8b c6	 mov	 r8d, r14d
  006b5	41 83 e0 7f	 and	 r8d, 127		; 0000007fH
  006b9	41 83 c0 0b	 add	 r8d, 11
  006bd	41 c1 ee 07	 shr	 r14d, 7
$LN483@inflateBac:
  006c1	41 2b c5	 sub	 eax, r13d
  006c4	4c 8b 6d 30	 mov	 r13, QWORD PTR in$[rbp-120]
  006c8	45 33 c9	 xor	 r9d, r9d
  006cb	03 f0		 add	 esi, eax
$LN138@inflateBac:

; 435  :                     }
; 436  :                     if (state->have + copy > state->nlen + state->ndist) {

  006cd	41 8b 57 78	 mov	 edx, DWORD PTR [r15+120]
  006d1	41 8b 4f 7c	 mov	 ecx, DWORD PTR [r15+124]
  006d5	41 03 57 74	 add	 edx, DWORD PTR [r15+116]
  006d9	41 03 c8	 add	 ecx, r8d
  006dc	3b ca		 cmp	 ecx, edx
  006de	77 65		 ja	 SHORT $LN374@inflateBac

; 437  :                         strm->msg = (char *)"invalid bit length repeat";
; 438  :                         state->mode = BAD;
; 439  :                         break;
; 440  :                     }
; 441  :                     while (copy--)

  006e0	45 85 c0	 test	 r8d, r8d
  006e3	74 25		 je	 SHORT $LN478@inflateBac
  006e5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL136@inflateBac:

; 442  :                         state->lens[state->have++] = (unsigned short)len;

  006f0	41 8b 47 7c	 mov	 eax, DWORD PTR [r15+124]
  006f4	66 45 89 8c 47
	88 00 00 00	 mov	 WORD PTR [r15+rax*2+136], r9w
  006fd	41 ff 47 7c	 inc	 DWORD PTR [r15+124]
  00701	41 ff c8	 dec	 r8d
  00704	75 ea		 jne	 SHORT $LL136@inflateBac

; 437  :                         strm->msg = (char *)"invalid bit length repeat";
; 438  :                         state->mode = BAD;
; 439  :                         break;
; 440  :                     }
; 441  :                     while (copy--)

  00706	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN478@inflateBac:
  0070a	49 8d 5f 68	 lea	 rbx, QWORD PTR [r15+104]
$LN400@inflateBac:

; 394  :             }
; 395  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 396  : 
; 397  :             /* get length and distance code code lengths */
; 398  :             state->have = 0;
; 399  :             while (state->have < state->nlen + state->ndist) {

  0070e	41 8b 47 78	 mov	 eax, DWORD PTR [r15+120]
  00712	41 03 47 74	 add	 eax, DWORD PTR [r15+116]
  00716	41 39 47 7c	 cmp	 DWORD PTR [r15+124], eax
  0071a	0f 82 b0 fd ff
	ff		 jb	 $LL217@inflateBac

; 513  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 514  :                         "inflate:         literal '%c'\n" :
; 515  :                         "inflate:         literal 0x%02x\n", here.val));
; 516  :                 ROOM();

  00720	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
$LN216@inflateBac:

; 443  :                 }
; 444  :             }
; 445  : 
; 446  :             /* handle error breaks in while */
; 447  :             if (state->mode == BAD) break;

  00724	41 83 3f 1d	 cmp	 DWORD PTR [r15], 29
  00728	0f 84 6e 03 00
	00		 je	 $LN479@inflateBac

; 448  : 
; 449  :             /* check for end-of-block code (better have one) */
; 450  :             if (state->lens[256] == 0) {

  0072e	66 41 83 bf 88
	02 00 00 00	 cmp	 WORD PTR [r15+648], 0
  00737	75 24		 jne	 SHORT $LN133@inflateBac

; 451  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00739	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@

; 452  :                 state->mode = BAD;
; 453  :                 break;

  00740	e9 4e fd ff ff	 jmp	 $LN490@inflateBac
$LN374@inflateBac:

; 414  :                             strm->msg = (char *)"invalid bit length repeat";

  00745	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]

; 415  :                             state->mode = BAD;
; 416  :                             break;

  00749	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  0074d	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  00751	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
  00758	e9 3e 01 00 00	 jmp	 $LN485@inflateBac
$LN133@inflateBac:

; 454  :             }
; 455  : 
; 456  :             /* build code tables -- note: do not change the lenbits or distbits
; 457  :                values here (9 and 6) without reading the comments in inftrees.h
; 458  :                concerning the ENOUGH constants, which depend on those values */
; 459  :             state->next = state->codes;

  0075d	49 8d 87 48 05
	00 00		 lea	 rax, QWORD PTR [r15+1352]

; 460  :             state->lencode = (code const FAR *)(state->next);
; 461  :             state->lenbits = 9;
; 462  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 463  :                                 &(state->lenbits), state->work);

  00764	4d 8d 87 08 03
	00 00		 lea	 r8, QWORD PTR [r15+776]
  0076b	4d 8d 8f 80 00
	00 00		 lea	 r9, QWORD PTR [r15+128]
  00772	4c 89 44 24 28	 mov	 QWORD PTR [rsp+40], r8
  00777	45 8b 47 74	 mov	 r8d, DWORD PTR [r15+116]
  0077b	49 89 87 80 00
	00 00		 mov	 QWORD PTR [r15+128], rax
  00782	49 89 47 58	 mov	 QWORD PTR [r15+88], rax
  00786	49 8d 47 68	 lea	 rax, QWORD PTR [r15+104]
  0078a	49 8d 97 88 00
	00 00		 lea	 rdx, QWORD PTR [r15+136]
  00791	b9 01 00 00 00	 mov	 ecx, 1
  00796	c7 00 09 00 00
	00		 mov	 DWORD PTR [rax], 9
  0079c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007a1	e8 00 00 00 00	 call	 inflate_table

; 464  :             if (ret) {

  007a6	85 c0		 test	 eax, eax
  007a8	74 0c		 je	 SHORT $LN132@inflateBac

; 465  :                 strm->msg = (char *)"invalid literal/lengths set";

  007aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@

; 466  :                 state->mode = BAD;
; 467  :                 break;

  007b1	e9 dd fc ff ff	 jmp	 $LN490@inflateBac
$LN132@inflateBac:

; 468  :             }
; 469  :             state->distcode = (code const FAR *)(state->next);
; 470  :             state->distbits = 6;
; 471  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 472  :                             &(state->next), &(state->distbits), state->work);

  007b6	45 8b 47 78	 mov	 r8d, DWORD PTR [r15+120]
  007ba	49 8d 4f 6c	 lea	 rcx, QWORD PTR [r15+108]
  007be	4d 8d 8f 80 00
	00 00		 lea	 r9, QWORD PTR [r15+128]
  007c5	49 8b 01	 mov	 rax, QWORD PTR [r9]
  007c8	c7 01 06 00 00
	00		 mov	 DWORD PTR [rcx], 6
  007ce	49 89 47 60	 mov	 QWORD PTR [r15+96], rax
  007d2	41 8b 47 74	 mov	 eax, DWORD PTR [r15+116]
  007d6	48 83 c0 44	 add	 rax, 68			; 00000044H
  007da	49 8d 14 47	 lea	 rdx, QWORD PTR [r15+rax*2]
  007de	49 8d 87 08 03
	00 00		 lea	 rax, QWORD PTR [r15+776]
  007e5	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  007ea	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  007ef	b9 02 00 00 00	 mov	 ecx, 2
  007f4	e8 00 00 00 00	 call	 inflate_table

; 473  :             if (ret) {
; 474  :                 strm->msg = (char *)"invalid distances set";

  007f9	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]

; 475  :                 state->mode = BAD;
; 476  :                 break;

  007fd	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  00801	85 c0		 test	 eax, eax
  00803	74 0c		 je	 SHORT $LN131@inflateBac

; 473  :             if (ret) {
; 474  :                 strm->msg = (char *)"invalid distances set";

  00805	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@

; 475  :                 state->mode = BAD;
; 476  :                 break;

  0080c	e9 8a 00 00 00	 jmp	 $LN485@inflateBac
$LN131@inflateBac:

; 477  :             }
; 478  :             Tracev((stderr, "inflate:       codes ok\n"));
; 479  :             state->mode = LEN;

  00811	41 c7 07 14 00
	00 00		 mov	 DWORD PTR [r15], 20
  00818	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  0081c	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN130@inflateBac:

; 480  : 
; 481  :         case LEN:
; 482  :             /* use inflate_fast() if we have enough input and output */
; 483  :             if (have >= 6 && left >= 258) {

  00822	83 ff 06	 cmp	 edi, 6
  00825	0f 82 86 00 00
	00		 jb	 $LN353@inflateBac
  0082b	41 81 f9 02 01
	00 00		 cmp	 r9d, 258		; 00000102H
  00832	72 7d		 jb	 SHORT $LN353@inflateBac

; 484  :                 RESTORE();

  00834	49 89 58 10	 mov	 QWORD PTR [r8+16], rbx
  00838	45 89 48 18	 mov	 DWORD PTR [r8+24], r9d
  0083c	4d 89 10	 mov	 QWORD PTR [r8], r10
  0083f	41 89 78 08	 mov	 DWORD PTR [r8+8], edi

; 485  :                 if (state->whave < state->wsize)

  00843	41 8b 57 2c	 mov	 edx, DWORD PTR [r15+44]
  00847	45 89 77 40	 mov	 DWORD PTR [r15+64], r14d
  0084b	41 89 77 44	 mov	 DWORD PTR [r15+68], esi
  0084f	41 39 57 30	 cmp	 DWORD PTR [r15+48], edx
  00853	73 09		 jae	 SHORT $LN125@inflateBac

; 486  :                     state->whave = state->wsize - left;

  00855	8b c2		 mov	 eax, edx
  00857	41 2b c1	 sub	 eax, r9d
  0085a	41 89 47 30	 mov	 DWORD PTR [r15+48], eax
$LN125@inflateBac:

; 487  :                 inflate_fast(strm, state->wsize);

  0085e	49 8b c8	 mov	 rcx, r8
  00861	e8 00 00 00 00	 call	 inflate_fast

; 488  :                 LOAD();

  00866	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
  0086a	33 d2		 xor	 edx, edx
  0086c	4d 8b 10	 mov	 r10, QWORD PTR [r8]
  0086f	49 8b 58 10	 mov	 rbx, QWORD PTR [r8+16]
  00873	45 8b 48 18	 mov	 r9d, DWORD PTR [r8+24]
  00877	41 8b 78 08	 mov	 edi, DWORD PTR [r8+8]
  0087b	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  0087f	45 8b 77 40	 mov	 r14d, DWORD PTR [r15+64]
  00883	41 8b 77 44	 mov	 esi, DWORD PTR [r15+68]
  00887	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  0088b	44 89 4d b8	 mov	 DWORD PTR left$1$[rbp-120], r9d
  0088f	e9 12 02 00 00	 jmp	 $LN387@inflateBac
$LN239@inflateBac:

; 369  :                 strm->msg = (char *)"too many length or distance symbols";

  00894	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
$LN485@inflateBac:
  0089b	49 89 40 20	 mov	 QWORD PTR [r8+32], rax

; 370  :                 state->mode = BAD;

  0089f	41 c7 07 1d 00
	00 00		 mov	 DWORD PTR [r15], 29

; 371  :                 break;

  008a6	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  008aa	33 d2		 xor	 edx, edx
  008ac	e9 f5 01 00 00	 jmp	 $LN387@inflateBac
$LN353@inflateBac:

; 489  :                 break;
; 490  :             }
; 491  : 
; 492  :             /* get a literal, length, or end-of-block code */
; 493  :             for (;;) {
; 494  :                 here = state->lencode[BITS(state->lenbits)];

  008b1	41 8b 4f 68	 mov	 ecx, DWORD PTR [r15+104]
  008b5	41 8b c3	 mov	 eax, r11d
  008b8	d3 e0		 shl	 eax, cl
  008ba	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  008bd	41 8b c6	 mov	 eax, r14d
  008c0	48 23 c8	 and	 rcx, rax
  008c3	49 8b 47 58	 mov	 rax, QWORD PTR [r15+88]
  008c7	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]

; 495  :                 if ((unsigned)(here.bits) <= bits) break;

  008ca	8b c8		 mov	 ecx, eax
  008cc	c1 e9 08	 shr	 ecx, 8
  008cf	0f b6 c9	 movzx	 ecx, cl
  008d2	3b ce		 cmp	 ecx, esi
  008d4	76 5e		 jbe	 SHORT $LN376@inflateBac
$LL121@inflateBac:

; 496  :                 PULLBYTE();

  008d6	85 ff		 test	 edi, edi
  008d8	75 1e		 jne	 SHORT $LN114@inflateBac
  008da	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  008de	49 8b cc	 mov	 rcx, r12
  008e1	41 ff d5	 call	 r13
  008e4	8b f8		 mov	 edi, eax
  008e6	85 c0		 test	 eax, eax
  008e8	0f 84 17 05 00
	00		 je	 $LN363@inflateBac
  008ee	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  008f2	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN114@inflateBac:
  008f8	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  008fc	8b ce		 mov	 ecx, esi
  008fe	49 ff c2	 inc	 r10
  00901	d3 e0		 shl	 eax, cl
  00903	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00907	41 8b 4f 68	 mov	 ecx, DWORD PTR [r15+104]
  0090b	44 03 f0	 add	 r14d, eax
  0090e	41 8b c3	 mov	 eax, r11d
  00911	83 c6 08	 add	 esi, 8
  00914	d3 e0		 shl	 eax, cl
  00916	ff cf		 dec	 edi
  00918	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  0091b	41 8b c6	 mov	 eax, r14d
  0091e	48 23 c8	 and	 rcx, rax
  00921	49 8b 47 58	 mov	 rax, QWORD PTR [r15+88]
  00925	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00928	8b c8		 mov	 ecx, eax
  0092a	c1 e9 08	 shr	 ecx, 8
  0092d	0f b6 c9	 movzx	 ecx, cl
  00930	3b ce		 cmp	 ecx, esi
  00932	77 a2		 ja	 SHORT $LL121@inflateBac
$LN376@inflateBac:

; 497  :             }
; 498  :             if (here.op && (here.op & 0xf0) == 0) {

  00934	84 c0		 test	 al, al
  00936	0f 84 d4 00 00
	00		 je	 $LN96@inflateBac
  0093c	a8 f0		 test	 al, 240			; 000000f0H
  0093e	0f 85 cc 00 00
	00		 jne	 $LN96@inflateBac

; 499  :                 last = here;
; 500  :                 for (;;) {
; 501  :                     here = state->lencode[last.val +
; 502  :                             (BITS(last.bits + last.op) >> last.bits)];

  00944	44 8b c8	 mov	 r9d, eax
  00947	0f b6 c8	 movzx	 ecx, al
  0094a	89 45 bc	 mov	 DWORD PTR last$[rbp-120], eax

; 503  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  0094d	44 0f b6 65 bd	 movzx	 r12d, BYTE PTR last$[rbp-119]
  00952	41 c1 e9 08	 shr	 r9d, 8
  00956	8b d8		 mov	 ebx, eax
  00958	c1 e8 10	 shr	 eax, 16
  0095b	41 0f b6 d1	 movzx	 edx, r9b
  0095f	45 8b c3	 mov	 r8d, r11d
  00962	03 ca		 add	 ecx, edx
  00964	41 d3 e0	 shl	 r8d, cl
  00967	8b ca		 mov	 ecx, edx
  00969	41 ff c8	 dec	 r8d
  0096c	45 23 c6	 and	 r8d, r14d
  0096f	41 d3 e8	 shr	 r8d, cl
  00972	44 03 c0	 add	 r8d, eax
  00975	49 8b 47 58	 mov	 rax, QWORD PTR [r15+88]
  00979	42 8b 04 80	 mov	 eax, DWORD PTR [rax+r8*4]
  0097d	8b c8		 mov	 ecx, eax
  0097f	c1 e9 08	 shr	 ecx, 8
  00982	0f b6 d1	 movzx	 edx, cl
  00985	41 0f b6 c9	 movzx	 ecx, r9b
  00989	03 d1		 add	 edx, ecx
  0098b	3b d6		 cmp	 edx, esi
  0098d	76 74		 jbe	 SHORT $LN98@inflateBac
  0098f	44 0f b7 6d be	 movzx	 r13d, WORD PTR last$[rbp-118]
$LL109@inflateBac:

; 504  :                     PULLBYTE();

  00994	85 ff		 test	 edi, edi
  00996	75 1f		 jne	 SHORT $LN102@inflateBac
  00998	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  0099c	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  009a0	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  009a3	8b f8		 mov	 edi, eax
  009a5	85 c0		 test	 eax, eax
  009a7	0f 84 58 04 00
	00		 je	 $LN363@inflateBac
  009ad	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  009b1	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN102@inflateBac:
  009b7	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  009bb	8b ce		 mov	 ecx, esi
  009bd	45 0f b6 c4	 movzx	 r8d, r12b
  009c1	d3 e0		 shl	 eax, cl
  009c3	41 8b d3	 mov	 edx, r11d
  009c6	49 ff c2	 inc	 r10
  009c9	44 03 f0	 add	 r14d, eax
  009cc	41 0f b7 c5	 movzx	 eax, r13w
  009d0	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  009d4	0f b6 cb	 movzx	 ecx, bl
  009d7	83 c6 08	 add	 esi, 8
  009da	ff cf		 dec	 edi
  009dc	41 03 c8	 add	 ecx, r8d
  009df	d3 e2		 shl	 edx, cl
  009e1	41 8b c8	 mov	 ecx, r8d
  009e4	ff ca		 dec	 edx
  009e6	41 23 d6	 and	 edx, r14d
  009e9	d3 ea		 shr	 edx, cl
  009eb	03 d0		 add	 edx, eax
  009ed	49 8b 47 58	 mov	 rax, QWORD PTR [r15+88]
  009f1	8b 04 90	 mov	 eax, DWORD PTR [rax+rdx*4]
  009f4	8b c8		 mov	 ecx, eax
  009f6	c1 e9 08	 shr	 ecx, 8
  009f9	0f b6 d1	 movzx	 edx, cl
  009fc	41 03 d0	 add	 edx, r8d
  009ff	3b d6		 cmp	 edx, esi
  00a01	77 91		 ja	 SHORT $LL109@inflateBac
$LN98@inflateBac:

; 505  :                 }
; 506  :                 DROPBITS(last.bits);

  00a03	41 0f b6 cc	 movzx	 ecx, r12b
  00a07	4c 8b 65 38	 mov	 r12, QWORD PTR in_desc$[rbp-120]
  00a0b	41 d3 ee	 shr	 r14d, cl
  00a0e	2b f1		 sub	 esi, ecx
$LN96@inflateBac:

; 507  :             }
; 508  :             DROPBITS(here.bits);

  00a10	8b c8		 mov	 ecx, eax
  00a12	c1 e9 08	 shr	 ecx, 8
  00a15	0f b6 c9	 movzx	 ecx, cl
  00a18	41 d3 ee	 shr	 r14d, cl
  00a1b	2b f1		 sub	 esi, ecx

; 509  :             state->length = (unsigned)here.val;

  00a1d	8b c8		 mov	 ecx, eax
  00a1f	c1 e9 10	 shr	 ecx, 16
  00a22	41 89 4f 48	 mov	 DWORD PTR [r15+72], ecx

; 510  : 
; 511  :             /* process literal */
; 512  :             if (here.op == 0) {

  00a26	84 c0		 test	 al, al
  00a28	75 5f		 jne	 SHORT $LN92@inflateBac

; 513  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 514  :                         "inflate:         literal '%c'\n" :
; 515  :                         "inflate:         literal 0x%02x\n", here.val));
; 516  :                 ROOM();

  00a2a	44 8b 65 b8	 mov	 r12d, DWORD PTR left$1$[rbp-120]
  00a2e	45 85 e4	 test	 r12d, r12d
  00a31	75 2c		 jne	 SHORT $LN477@inflateBac
  00a33	45 8b 67 2c	 mov	 r12d, DWORD PTR [r15+44]
  00a37	49 8b 5f 38	 mov	 rbx, QWORD PTR [r15+56]
  00a3b	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00a3f	45 8b c4	 mov	 r8d, r12d
  00a42	48 8b d3	 mov	 rdx, rbx
  00a45	45 89 67 30	 mov	 DWORD PTR [r15+48], r12d
  00a49	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00a4c	85 c0		 test	 eax, eax
  00a4e	74 13		 je	 SHORT $LN90@inflateBac
$LN366@inflateBac:

; 344  :                 ROOM();

  00a50	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00a54	41 bb fb ff ff
	ff		 mov	 r11d, -5
  00a5a	e9 e4 03 00 00	 jmp	 $inf_leave$495
$LN477@inflateBac:
  00a5f	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
$LN90@inflateBac:

; 517  :                 *put++ = (unsigned char)(state->length);

  00a63	41 0f b6 47 48	 movzx	 eax, BYTE PTR [r15+72]
  00a68	48 ff c3	 inc	 rbx

; 518  :                 left--;

  00a6b	41 ff cc	 dec	 r12d
  00a6e	88 43 ff	 mov	 BYTE PTR [rbx-1], al

; 519  :                 state->mode = LEN;

  00a71	41 c7 07 14 00
	00 00		 mov	 DWORD PTR [r15], 20

; 520  :                 break;

  00a78	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00a7c	44 89 65 b8	 mov	 DWORD PTR left$1$[rbp-120], r12d
  00a80	45 8b cc	 mov	 r9d, r12d
  00a83	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  00a87	eb 17		 jmp	 SHORT $LN484@inflateBac
$LN92@inflateBac:

; 521  :             }
; 522  : 
; 523  :             /* process end of block */
; 524  :             if (here.op & 32) {

  00a89	a8 20		 test	 al, 32			; 00000020H
  00a8b	74 35		 je	 SHORT $LN86@inflateBac

; 525  :                 Tracevv((stderr, "inflate:         end of block\n"));
; 526  :                 state->mode = TYPE;
; 527  :                 break;

  00a8d	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00a91	41 c7 07 0b 00
	00 00		 mov	 DWORD PTR [r15], 11
  00a98	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN479@inflateBac:
  00a9c	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
$LN484@inflateBac:
  00aa0	33 d2		 xor	 edx, edx
$LN481@inflateBac:
  00aa2	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
$LN387@inflateBac:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;
; 287  :     left = state->wsize;
; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  00aa6	41 8b 07	 mov	 eax, DWORD PTR [r15]
  00aa9	83 e8 0b	 sub	 eax, 11
  00aac	83 f8 12	 cmp	 eax, 18
  00aaf	0f 87 88 03 00
	00		 ja	 $LN1@inflateBac
  00ab5	4c 8b 65 38	 mov	 r12, QWORD PTR in_desc$[rbp-120]
  00ab9	4c 8b 6d 30	 mov	 r13, QWORD PTR in$[rbp-120]
  00abd	e9 d6 f5 ff ff	 jmp	 $LN488@inflateBac
$LN86@inflateBac:

; 528  :             }
; 529  : 
; 530  :             /* invalid code */
; 531  :             if (here.op & 64) {

  00ac2	a8 40		 test	 al, 64			; 00000040H
  00ac4	74 18		 je	 SHORT $LN85@inflateBac

; 532  :                 strm->msg = (char *)"invalid literal/length code";

  00ac6	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]

; 533  :                 state->mode = BAD;
; 534  :                 break;

  00aca	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00ace	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  00ad2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
  00ad9	e9 bd fd ff ff	 jmp	 $LN485@inflateBac
$LN85@inflateBac:

; 535  :             }
; 536  : 
; 537  :             /* length code -- get extra bits, if any */
; 538  :             state->extra = (unsigned)(here.op) & 15;

  00ade	0f b6 c8	 movzx	 ecx, al
  00ae1	83 e1 0f	 and	 ecx, 15
  00ae4	41 89 4f 50	 mov	 DWORD PTR [r15+80], ecx

; 539  :             if (state->extra != 0) {

  00ae8	74 5d		 je	 SHORT $LN68@inflateBac

; 540  :                 NEEDBITS(state->extra);

  00aea	3b f1		 cmp	 esi, ecx
  00aec	73 42		 jae	 SHORT $LN82@inflateBac
  00aee	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LL80@inflateBac:
  00af2	85 ff		 test	 edi, edi
  00af4	75 18		 jne	 SHORT $LN74@inflateBac
  00af6	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00afa	49 8b cc	 mov	 rcx, r12
  00afd	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00b00	8b f8		 mov	 edi, eax
  00b02	85 c0		 test	 eax, eax
  00b04	0f 84 fb 02 00
	00		 je	 $LN363@inflateBac
  00b0a	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN74@inflateBac:
  00b0e	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00b11	8b ce		 mov	 ecx, esi
  00b13	48 ff c2	 inc	 rdx
  00b16	d3 e0		 shl	 eax, cl
  00b18	83 c6 08	 add	 esi, 8
  00b1b	ff cf		 dec	 edi
  00b1d	44 03 f0	 add	 r14d, eax
  00b20	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  00b24	41 3b 77 50	 cmp	 esi, DWORD PTR [r15+80]
  00b28	72 c8		 jb	 SHORT $LL80@inflateBac
  00b2a	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN82@inflateBac:

; 541  :                 state->length += BITS(state->extra);

  00b30	41 8b 4f 50	 mov	 ecx, DWORD PTR [r15+80]
  00b34	41 8b c3	 mov	 eax, r11d
  00b37	d3 e0		 shl	 eax, cl
  00b39	ff c8		 dec	 eax
  00b3b	41 23 c6	 and	 eax, r14d

; 542  :                 DROPBITS(state->extra);

  00b3e	41 d3 ee	 shr	 r14d, cl
  00b41	41 01 47 48	 add	 DWORD PTR [r15+72], eax
  00b45	2b f1		 sub	 esi, ecx
$LN68@inflateBac:

; 543  :             }
; 544  :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 545  : 
; 546  :             /* get distance code */
; 547  :             for (;;) {
; 548  :                 here = state->distcode[BITS(state->distbits)];

  00b47	41 8b 4f 6c	 mov	 ecx, DWORD PTR [r15+108]

; 549  :                 if ((unsigned)(here.bits) <= bits) break;

  00b4b	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00b4f	41 8b c3	 mov	 eax, r11d
  00b52	d3 e0		 shl	 eax, cl
  00b54	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00b57	41 8b c6	 mov	 eax, r14d
  00b5a	48 23 c8	 and	 rcx, rax
  00b5d	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  00b61	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00b64	8b c8		 mov	 ecx, eax
  00b66	c1 e9 08	 shr	 ecx, 8
  00b69	0f b6 c9	 movzx	 ecx, cl
  00b6c	3b ce		 cmp	 ecx, esi
  00b6e	76 5e		 jbe	 SHORT $LN381@inflateBac
$LL67@inflateBac:

; 550  :                 PULLBYTE();

  00b70	85 ff		 test	 edi, edi
  00b72	75 1e		 jne	 SHORT $LN60@inflateBac
  00b74	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00b78	49 8b cc	 mov	 rcx, r12
  00b7b	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00b7e	8b f8		 mov	 edi, eax
  00b80	85 c0		 test	 eax, eax
  00b82	0f 84 7d 02 00
	00		 je	 $LN363@inflateBac
  00b88	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00b8c	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN60@inflateBac:
  00b92	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00b96	8b ce		 mov	 ecx, esi
  00b98	49 ff c2	 inc	 r10
  00b9b	d3 e0		 shl	 eax, cl
  00b9d	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00ba1	41 8b 4f 6c	 mov	 ecx, DWORD PTR [r15+108]
  00ba5	44 03 f0	 add	 r14d, eax
  00ba8	41 8b c3	 mov	 eax, r11d
  00bab	83 c6 08	 add	 esi, 8
  00bae	d3 e0		 shl	 eax, cl
  00bb0	ff cf		 dec	 edi
  00bb2	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00bb5	41 8b c6	 mov	 eax, r14d
  00bb8	48 23 c8	 and	 rcx, rax
  00bbb	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  00bbf	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00bc2	8b c8		 mov	 ecx, eax
  00bc4	c1 e9 08	 shr	 ecx, 8
  00bc7	0f b6 c9	 movzx	 ecx, cl
  00bca	3b ce		 cmp	 ecx, esi
  00bcc	77 a2		 ja	 SHORT $LL67@inflateBac
$LN381@inflateBac:

; 551  :             }
; 552  :             if ((here.op & 0xf0) == 0) {

  00bce	a8 f0		 test	 al, 240			; 000000f0H
  00bd0	0f 85 c8 00 00
	00		 jne	 $LN42@inflateBac

; 553  :                 last = here;
; 554  :                 for (;;) {
; 555  :                     here = state->distcode[last.val +
; 556  :                             (BITS(last.bits + last.op) >> last.bits)];

  00bd6	44 8b c8	 mov	 r9d, eax
  00bd9	0f b6 c8	 movzx	 ecx, al
  00bdc	89 45 bc	 mov	 DWORD PTR last$[rbp-120], eax

; 557  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00bdf	44 0f b6 6d bd	 movzx	 r13d, BYTE PTR last$[rbp-119]
  00be4	41 c1 e9 08	 shr	 r9d, 8
  00be8	8b d8		 mov	 ebx, eax
  00bea	c1 e8 10	 shr	 eax, 16
  00bed	41 0f b6 d1	 movzx	 edx, r9b
  00bf1	45 8b c3	 mov	 r8d, r11d
  00bf4	03 ca		 add	 ecx, edx
  00bf6	41 d3 e0	 shl	 r8d, cl
  00bf9	8b ca		 mov	 ecx, edx
  00bfb	41 ff c8	 dec	 r8d
  00bfe	45 23 c6	 and	 r8d, r14d
  00c01	41 d3 e8	 shr	 r8d, cl
  00c04	44 03 c0	 add	 r8d, eax
  00c07	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  00c0b	42 8b 04 80	 mov	 eax, DWORD PTR [rax+r8*4]
  00c0f	8b c8		 mov	 ecx, eax
  00c11	c1 e9 08	 shr	 ecx, 8
  00c14	0f b6 d1	 movzx	 edx, cl
  00c17	41 0f b6 c9	 movzx	 ecx, r9b
  00c1b	03 d1		 add	 edx, ecx
  00c1d	3b d6		 cmp	 edx, esi
  00c1f	76 74		 jbe	 SHORT $LN44@inflateBac
  00c21	44 0f b7 65 be	 movzx	 r12d, WORD PTR last$[rbp-118]
$LL55@inflateBac:

; 558  :                     PULLBYTE();

  00c26	85 ff		 test	 edi, edi
  00c28	75 1f		 jne	 SHORT $LN48@inflateBac
  00c2a	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  00c2e	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00c32	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00c35	8b f8		 mov	 edi, eax
  00c37	85 c0		 test	 eax, eax
  00c39	0f 84 c6 01 00
	00		 je	 $LN363@inflateBac
  00c3f	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00c43	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN48@inflateBac:
  00c49	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00c4d	8b ce		 mov	 ecx, esi
  00c4f	45 0f b6 c5	 movzx	 r8d, r13b
  00c53	d3 e0		 shl	 eax, cl
  00c55	41 8b d3	 mov	 edx, r11d
  00c58	49 ff c2	 inc	 r10
  00c5b	44 03 f0	 add	 r14d, eax
  00c5e	41 0f b7 c4	 movzx	 eax, r12w
  00c62	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00c66	0f b6 cb	 movzx	 ecx, bl
  00c69	83 c6 08	 add	 esi, 8
  00c6c	ff cf		 dec	 edi
  00c6e	41 03 c8	 add	 ecx, r8d
  00c71	d3 e2		 shl	 edx, cl
  00c73	41 8b c8	 mov	 ecx, r8d
  00c76	ff ca		 dec	 edx
  00c78	41 23 d6	 and	 edx, r14d
  00c7b	d3 ea		 shr	 edx, cl
  00c7d	03 d0		 add	 edx, eax
  00c7f	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  00c83	8b 04 90	 mov	 eax, DWORD PTR [rax+rdx*4]
  00c86	8b c8		 mov	 ecx, eax
  00c88	c1 e9 08	 shr	 ecx, 8
  00c8b	0f b6 d1	 movzx	 edx, cl
  00c8e	41 03 d0	 add	 edx, r8d
  00c91	3b d6		 cmp	 edx, esi
  00c93	77 91		 ja	 SHORT $LL55@inflateBac
$LN44@inflateBac:

; 559  :                 }
; 560  :                 DROPBITS(last.bits);

  00c95	41 0f b6 cd	 movzx	 ecx, r13b
  00c99	41 d3 ee	 shr	 r14d, cl
  00c9c	2b f1		 sub	 esi, ecx
$LN42@inflateBac:

; 561  :             }
; 562  :             DROPBITS(here.bits);

  00c9e	8b c8		 mov	 ecx, eax
  00ca0	c1 e9 08	 shr	 ecx, 8
  00ca3	0f b6 c9	 movzx	 ecx, cl
  00ca6	41 d3 ee	 shr	 r14d, cl
  00ca9	2b f1		 sub	 esi, ecx

; 563  :             if (here.op & 64) {

  00cab	a8 40		 test	 al, 64			; 00000040H
  00cad	74 18		 je	 SHORT $LN38@inflateBac

; 533  :                 state->mode = BAD;
; 534  :                 break;

  00caf	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
  00cb3	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00cb7	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]

; 564  :                 strm->msg = (char *)"invalid distance code";

  00cbb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  00cc2	e9 d4 fb ff ff	 jmp	 $LN485@inflateBac
$LN38@inflateBac:

; 565  :                 state->mode = BAD;
; 566  :                 break;
; 567  :             }
; 568  :             state->offset = (unsigned)here.val;

  00cc7	8b c8		 mov	 ecx, eax
  00cc9	c1 e9 10	 shr	 ecx, 16
  00ccc	41 89 4f 4c	 mov	 DWORD PTR [r15+76], ecx

; 569  : 
; 570  :             /* get distance extra bits, if any */
; 571  :             state->extra = (unsigned)(here.op) & 15;

  00cd0	0f b6 c8	 movzx	 ecx, al
  00cd3	83 e1 0f	 and	 ecx, 15
  00cd6	41 89 4f 50	 mov	 DWORD PTR [r15+80], ecx

; 572  :             if (state->extra != 0) {

  00cda	74 5e		 je	 SHORT $LN21@inflateBac

; 573  :                 NEEDBITS(state->extra);

  00cdc	3b f1		 cmp	 esi, ecx
  00cde	73 43		 jae	 SHORT $LN35@inflateBac
  00ce0	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LL33@inflateBac:
  00ce4	85 ff		 test	 edi, edi
  00ce6	75 19		 jne	 SHORT $LN27@inflateBac
  00ce8	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  00cec	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00cf0	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00cf3	8b f8		 mov	 edi, eax
  00cf5	85 c0		 test	 eax, eax
  00cf7	0f 84 08 01 00
	00		 je	 $LN363@inflateBac
  00cfd	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN27@inflateBac:
  00d01	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00d04	8b ce		 mov	 ecx, esi
  00d06	48 ff c2	 inc	 rdx
  00d09	d3 e0		 shl	 eax, cl
  00d0b	83 c6 08	 add	 esi, 8
  00d0e	ff cf		 dec	 edi
  00d10	44 03 f0	 add	 r14d, eax
  00d13	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  00d17	41 3b 77 50	 cmp	 esi, DWORD PTR [r15+80]
  00d1b	72 c7		 jb	 SHORT $LL33@inflateBac
  00d1d	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN35@inflateBac:

; 574  :                 state->offset += BITS(state->extra);

  00d23	41 8b 4f 50	 mov	 ecx, DWORD PTR [r15+80]
  00d27	41 8b c3	 mov	 eax, r11d
  00d2a	d3 e0		 shl	 eax, cl
  00d2c	ff c8		 dec	 eax
  00d2e	41 23 c6	 and	 eax, r14d

; 575  :                 DROPBITS(state->extra);

  00d31	41 d3 ee	 shr	 r14d, cl
  00d34	41 01 47 4c	 add	 DWORD PTR [r15+76], eax
  00d38	2b f1		 sub	 esi, ecx
$LN21@inflateBac:

; 576  :             }
; 577  :             if (state->offset > state->wsize - (state->whave < state->wsize ?
; 578  :                                                 left : 0)) {

  00d3a	41 8b 4f 2c	 mov	 ecx, DWORD PTR [r15+44]
  00d3e	44 8b 65 b8	 mov	 r12d, DWORD PTR left$1$[rbp-120]

; 580  :                 state->mode = BAD;
; 581  :                 break;

  00d42	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00d46	33 d2		 xor	 edx, edx
  00d48	41 39 4f 30	 cmp	 DWORD PTR [r15+48], ecx
  00d4c	8b c2		 mov	 eax, edx
  00d4e	41 0f 42 c4	 cmovb	 eax, r12d
  00d52	2b c8		 sub	 ecx, eax
  00d54	41 39 4f 4c	 cmp	 DWORD PTR [r15+76], ecx
  00d58	76 26		 jbe	 SHORT $LL19@inflateBac

; 579  :                 strm->msg = (char *)"invalid distance too far back";

  00d5a	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
  00d5e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@

; 580  :                 state->mode = BAD;
; 581  :                 break;

  00d65	45 8b cc	 mov	 r9d, r12d
  00d68	49 89 40 20	 mov	 QWORD PTR [r8+32], rax
  00d6c	41 c7 07 1d 00
	00 00		 mov	 DWORD PTR [r15], 29
  00d73	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00d77	e9 2a fd ff ff	 jmp	 $LN387@inflateBac
  00d7c	0f 1f 40 00	 npad	 4
$LL19@inflateBac:

; 582  :             }
; 583  :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 584  : 
; 585  :             /* copy match from window to output */
; 586  :             do {
; 587  :                 ROOM();

  00d80	45 85 e4	 test	 r12d, r12d
  00d83	75 21		 jne	 SHORT $LN15@inflateBac
  00d85	45 8b 67 2c	 mov	 r12d, DWORD PTR [r15+44]
  00d89	49 8b 5f 38	 mov	 rbx, QWORD PTR [r15+56]
  00d8d	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00d91	45 8b c4	 mov	 r8d, r12d
  00d94	48 8b d3	 mov	 rdx, rbx
  00d97	45 89 67 30	 mov	 DWORD PTR [r15+48], r12d
  00d9b	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00d9e	85 c0		 test	 eax, eax
  00da0	0f 85 aa fc ff
	ff		 jne	 $LN366@inflateBac
$LN15@inflateBac:

; 588  :                 copy = state->wsize - state->offset;

  00da6	41 8b 4f 4c	 mov	 ecx, DWORD PTR [r15+76]
  00daa	41 8b 47 2c	 mov	 eax, DWORD PTR [r15+44]
  00dae	2b c1		 sub	 eax, ecx

; 589  :                 if (copy < left) {

  00db0	41 3b c4	 cmp	 eax, r12d
  00db3	73 0c		 jae	 SHORT $LN11@inflateBac

; 590  :                     from = put + copy;

  00db5	8b d0		 mov	 edx, eax

; 591  :                     copy = left - copy;

  00db7	41 8b cc	 mov	 ecx, r12d
  00dba	48 03 d3	 add	 rdx, rbx
  00dbd	2b c8		 sub	 ecx, eax

; 592  :                 }
; 593  :                 else {

  00dbf	eb 09		 jmp	 SHORT $LN10@inflateBac
$LN11@inflateBac:

; 594  :                     from = put - state->offset;

  00dc1	48 8b d3	 mov	 rdx, rbx
  00dc4	48 2b d1	 sub	 rdx, rcx

; 595  :                     copy = left;

  00dc7	41 8b cc	 mov	 ecx, r12d
$LN10@inflateBac:

; 596  :                 }
; 597  :                 if (copy > state->length) copy = state->length;

  00dca	41 3b 4f 48	 cmp	 ecx, DWORD PTR [r15+72]
  00dce	41 0f 47 4f 48	 cmova	 ecx, DWORD PTR [r15+72]

; 598  :                 state->length -= copy;

  00dd3	41 29 4f 48	 sub	 DWORD PTR [r15+72], ecx

; 599  :                 left -= copy;

  00dd7	44 2b e1	 sub	 r12d, ecx

; 602  :                 } while (--copy);

  00dda	48 2b d3	 sub	 rdx, rbx
  00ddd	44 89 65 b8	 mov	 DWORD PTR left$1$[rbp-120], r12d
$LL8@inflateBac:

; 600  :                 do {
; 601  :                     *put++ = *from++;

  00de1	0f b6 04 1a	 movzx	 eax, BYTE PTR [rdx+rbx]
  00de5	48 ff c3	 inc	 rbx
  00de8	88 43 ff	 mov	 BYTE PTR [rbx-1], al

; 602  :                 } while (--copy);

  00deb	ff c9		 dec	 ecx
  00ded	75 f2		 jne	 SHORT $LL8@inflateBac

; 603  :             } while (state->length != 0);

  00def	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  00df3	41 39 4f 48	 cmp	 DWORD PTR [r15+72], ecx
  00df7	75 87		 jne	 SHORT $LL19@inflateBac
  00df9	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00dfd	45 8b cc	 mov	 r9d, r12d
  00e00	e9 9b fc ff ff	 jmp	 $LN484@inflateBac
$LN363@inflateBac:

; 298  :             }
; 299  :             NEEDBITS(3);

  00e05	45 33 d2	 xor	 r10d, r10d
$LN489@inflateBac:
  00e08	41 bb fb ff ff
	ff		 mov	 r11d, -5
  00e0e	eb 33		 jmp	 SHORT $inf_leave$495
$LN5@inflateBac:

; 604  :             break;
; 605  : 
; 606  :         case DONE:
; 607  :             /* inflate stream terminated properly -- write leftover output */
; 608  :             ret = Z_STREAM_END;
; 609  :             if (left < state->wsize) {

  00e10	45 8b 47 2c	 mov	 r8d, DWORD PTR [r15+44]
  00e14	45 3b c8	 cmp	 r9d, r8d
  00e17	73 2a		 jae	 SHORT $inf_leave$495

; 610  :                 if (out(out_desc, state->window, state->wsize - left))

  00e19	49 8b 57 38	 mov	 rdx, QWORD PTR [r15+56]
  00e1d	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00e21	45 2b c1	 sub	 r8d, r9d
  00e24	ff 55 40	 call	 QWORD PTR out$[rbp-120]

; 611  :                     ret = Z_BUF_ERROR;
; 612  :             }
; 613  :             goto inf_leave;

  00e27	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00e2b	85 c0		 test	 eax, eax
  00e2d	75 d9		 jne	 SHORT $LN489@inflateBac
  00e2f	44 8d 58 01	 lea	 r11d, QWORD PTR [rax+1]
  00e33	eb 0e		 jmp	 SHORT $inf_leave$495
$LN2@inflateBac:

; 614  : 
; 615  :         case BAD:
; 616  :             ret = Z_DATA_ERROR;

  00e35	41 bb fd ff ff
	ff		 mov	 r11d, -3

; 617  :             goto inf_leave;

  00e3b	eb 06		 jmp	 SHORT $inf_leave$495
$LN1@inflateBac:

; 618  : 
; 619  :         default:                /* can't happen, but makes compilers happy */
; 620  :             ret = Z_STREAM_ERROR;

  00e3d	41 bb fe ff ff
	ff		 mov	 r11d, -2
$inf_leave$495:

; 621  :             goto inf_leave;
; 622  :         }
; 623  : 
; 624  :     /* Return unused input */
; 625  :   inf_leave:
; 626  :     strm->next_in = next;

  00e43	48 8b 45 28	 mov	 rax, QWORD PTR strm$[rbp-120]
  00e47	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]
  00e4c	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00e51	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]

; 627  :     strm->avail_in = have;

  00e56	89 78 08	 mov	 DWORD PTR [rax+8], edi
  00e59	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  00e5e	4c 89 10	 mov	 QWORD PTR [rax], r10

; 628  :     return ret;

  00e61	41 8b c3	 mov	 eax, r11d

; 629  : }

  00e64	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00e68	41 5f		 pop	 r15
  00e6a	41 5d		 pop	 r13
  00e6c	41 5c		 pop	 r12
  00e6e	5d		 pop	 rbp
  00e6f	c3		 ret	 0
$LN333@inflateBac:

; 274  :         return Z_STREAM_ERROR;

  00e70	b8 fe ff ff ff	 mov	 eax, -2

; 629  : }

  00e75	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00e79	41 5f		 pop	 r15
  00e7b	41 5d		 pop	 r13
  00e7d	41 5c		 pop	 r12
  00e7f	5d		 pop	 rbp
  00e80	c3		 ret	 0
  00e81	0f 1f 00	 npad	 3
$LN467@inflateBac:
  00e84	00 00 00 00	 DD	 $LN328@inflateBac
  00e88	00 00 00 00	 DD	 $LN1@inflateBac
  00e8c	00 00 00 00	 DD	 $LN297@inflateBac
  00e90	00 00 00 00	 DD	 $LN1@inflateBac
  00e94	00 00 00 00	 DD	 $LN1@inflateBac
  00e98	00 00 00 00	 DD	 $LN262@inflateBac
  00e9c	00 00 00 00	 DD	 $LN1@inflateBac
  00ea0	00 00 00 00	 DD	 $LN1@inflateBac
  00ea4	00 00 00 00	 DD	 $LN1@inflateBac
  00ea8	00 00 00 00	 DD	 $LN130@inflateBac
  00eac	00 00 00 00	 DD	 $LN1@inflateBac
  00eb0	00 00 00 00	 DD	 $LN1@inflateBac
  00eb4	00 00 00 00	 DD	 $LN1@inflateBac
  00eb8	00 00 00 00	 DD	 $LN1@inflateBac
  00ebc	00 00 00 00	 DD	 $LN1@inflateBac
  00ec0	00 00 00 00	 DD	 $LN1@inflateBac
  00ec4	00 00 00 00	 DD	 $LN1@inflateBac
  00ec8	00 00 00 00	 DD	 $LN5@inflateBac
  00ecc	00 00 00 00	 DD	 $LN2@inflateBac
inflateBack ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\projectsgit\gamecode4\source\gcc4\3rdparty\zlib-1.2.8\infback.c
;	COMDAT inflateBackEnd
_TEXT	SEGMENT
strm$ = 48
inflateBackEnd PROC					; COMDAT

; 633  : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 634  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 28		 je	 SHORT $LN1@inflateBac
  0000e	48 8b 51 28	 mov	 rdx, QWORD PTR [rcx+40]
  00012	48 85 d2	 test	 rdx, rdx
  00015	74 1f		 je	 SHORT $LN1@inflateBac
  00017	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  0001b	48 85 c0	 test	 rax, rax
  0001e	74 16		 je	 SHORT $LN1@inflateBac

; 636  :     ZFREE(strm, strm->state);

  00020	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00024	ff d0		 call	 rax

; 637  :     strm->state = Z_NULL;

  00026	48 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [rbx+40], 0

; 638  :     Tracev((stderr, "inflate: end\n"));
; 639  :     return Z_OK;

  0002e	33 c0		 xor	 eax, eax

; 640  : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
  00035	c3		 ret	 0
$LN1@inflateBac:

; 635  :         return Z_STREAM_ERROR;

  00036	b8 fe ff ff ff	 mov	 eax, -2

; 640  : }

  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5b		 pop	 rbx
  00040	c3		 ret	 0
inflateBackEnd ENDP
_TEXT	ENDS
END
