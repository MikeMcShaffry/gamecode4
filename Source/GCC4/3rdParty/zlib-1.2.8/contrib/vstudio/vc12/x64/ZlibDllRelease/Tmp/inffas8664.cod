; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

include listing.inc

INCLUDELIB OLDNAMES

EXTRN	inffas8664fnc:PROC
PUBLIC	inflate_fast
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate_fast DD imagerel $LN23
	DD	imagerel $LN23+423
	DD	imagerel $unwind$inflate_fast
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate_fast DD 091c01H
	DD	018741cH
	DD	017641cH
	DD	016341cH
	DD	014011cH
	DD	05010H
; Function compile flags: /Ogtpy
; File d:\projectsgit\gamecode4\source\gcc4\3rdparty\zlib-1.2.8\contrib\masmx64\inffas8664.c
;	COMDAT inflate_fast
_TEXT	SEGMENT
ar$ = 32
strm$ = 176
start$ = 184
inflate_fast PROC					; COMDAT

; 109  : {

$LN23:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	55		 push	 rbp
  00010	48 8d 6c 24 a9	 lea	 rbp, QWORD PTR [rsp-87]
  00015	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H

; 110  :     struct inflate_state FAR *state;
; 111  :     type_ar ar;
; 112  :     void inffas8664fnc(struct inffast_ar * par);
; 113  : 
; 114  : 
; 115  : 
; 116  : #if (defined( __GNUC__ ) && defined( __amd64__ ) && ! defined( __i386 )) || (defined(_MSC_VER) && defined(_M_AMD64))
; 117  : #define PAD_AVAIL_IN 6
; 118  : #define PAD_AVAIL_OUT 258
; 119  : #else
; 120  : #define PAD_AVAIL_IN 5
; 121  : #define PAD_AVAIL_OUT 257
; 122  : #endif
; 123  : 
; 124  :     /* copy state to local variables */
; 125  :     state = (struct inflate_state FAR *)strm->state;

  0001c	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]

; 126  : 
; 127  :     ar.in = strm->next_in;

  00020	4c 8b 11	 mov	 r10, QWORD PTR [rcx]

; 128  :     ar.last = ar.in + (strm->avail_in - PAD_AVAIL_IN);

  00023	44 8b 41 08	 mov	 r8d, DWORD PTR [rcx+8]
  00027	4c 89 55 e7	 mov	 QWORD PTR ar$[rbp-57], r10
  0002b	48 8b d9	 mov	 rbx, rcx
  0002e	8b c2		 mov	 eax, edx

; 129  :     ar.out = strm->next_out;
; 130  :     ar.beg = ar.out - (start - strm->avail_out);

  00030	8b 51 18	 mov	 edx, DWORD PTR [rcx+24]
  00033	41 83 e8 06	 sub	 r8d, 6

; 131  :     ar.end = ar.out + (strm->avail_out - PAD_AVAIL_OUT);
; 132  :     ar.wsize = state->wsize;
; 133  :     ar.write = state->wnext;
; 134  :     ar.window = state->window;
; 135  :     ar.hold = state->hold;
; 136  :     ar.bits = state->bits;
; 137  :     ar.lcode = state->lencode;
; 138  :     ar.dcode = state->distcode;
; 139  :     ar.lmask = (1U << state->lenbits) - 1;

  00037	be 01 00 00 00	 mov	 esi, 1
  0003c	2b c2		 sub	 eax, edx
  0003e	4d 03 c2	 add	 r8, r10
  00041	4c 89 45 ef	 mov	 QWORD PTR ar$[rbp-49], r8
  00045	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  00049	4c 89 45 f7	 mov	 QWORD PTR ar$[rbp-41], r8
  0004d	49 8b c8	 mov	 rcx, r8
  00050	48 2b c8	 sub	 rcx, rax
  00053	48 89 4d ff	 mov	 QWORD PTR ar$[rbp-33], rcx
  00057	8d 8a fe fe ff
	ff		 lea	 ecx, DWORD PTR [rdx-258]
  0005d	49 03 c8	 add	 rcx, r8
  00060	48 89 4d 07	 mov	 QWORD PTR ar$[rbp-25], rcx
  00064	8b 47 2c	 mov	 eax, DWORD PTR [rdi+44]
  00067	89 45 33	 mov	 DWORD PTR ar$[rbp+19], eax
  0006a	8b 47 34	 mov	 eax, DWORD PTR [rdi+52]
  0006d	89 45 37	 mov	 DWORD PTR ar$[rbp+23], eax
  00070	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00074	48 89 45 0f	 mov	 QWORD PTR ar$[rbp-17], rax
  00078	44 8b 47 40	 mov	 r8d, DWORD PTR [rdi+64]
  0007c	4c 89 45 27	 mov	 QWORD PTR ar$[rbp+7], r8
  00080	8b 57 44	 mov	 edx, DWORD PTR [rdi+68]
  00083	89 55 2f	 mov	 DWORD PTR ar$[rbp+15], edx
  00086	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0008a	48 89 45 17	 mov	 QWORD PTR ar$[rbp-9], rax
  0008e	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  00092	48 89 45 1f	 mov	 QWORD PTR ar$[rbp-1], rax
  00096	8b 4f 68	 mov	 ecx, DWORD PTR [rdi+104]
  00099	8b c6		 mov	 eax, esi
  0009b	d3 e0		 shl	 eax, cl
  0009d	ff c8		 dec	 eax
  0009f	89 45 3b	 mov	 DWORD PTR ar$[rbp+27], eax

; 140  :     ar.dmask = (1U << state->distbits) - 1;

  000a2	8b 4f 6c	 mov	 ecx, DWORD PTR [rdi+108]
  000a5	8b c6		 mov	 eax, esi
  000a7	d3 e0		 shl	 eax, cl
  000a9	ff c8		 dec	 eax
  000ab	89 45 3f	 mov	 DWORD PTR ar$[rbp+31], eax

; 141  : 
; 142  :     /* decode literals and length/distances until end-of-block or not enough
; 143  :        input data or output space */
; 144  : 
; 145  :     /* align in on 1/2 hold size boundary */
; 146  :     while (((size_t)(void *)ar.in & (sizeof(ar.hold) / 2 - 1)) != 0) {

  000ae	41 f6 c2 03	 test	 r10b, 3
  000b2	74 2e		 je	 SHORT $LN8@inflate_fa
  000b4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL9@inflate_fa:

; 147  :         ar.hold += (unsigned long)*ar.in++ << ar.bits;

  000c0	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  000c4	8b ca		 mov	 ecx, edx
  000c6	49 ff c2	 inc	 r10
  000c9	d3 e0		 shl	 eax, cl

; 148  :         ar.bits += 8;

  000cb	83 c2 08	 add	 edx, 8
  000ce	4c 89 55 e7	 mov	 QWORD PTR ar$[rbp-57], r10
  000d2	4c 03 c0	 add	 r8, rax
  000d5	89 55 2f	 mov	 DWORD PTR ar$[rbp+15], edx
  000d8	4c 89 45 27	 mov	 QWORD PTR ar$[rbp+7], r8
  000dc	41 f6 c2 03	 test	 r10b, 3
  000e0	75 de		 jne	 SHORT $LL9@inflate_fa
$LN8@inflate_fa:

; 149  :     }
; 150  : 
; 151  :     inffas8664fnc(&ar);

  000e2	48 8d 4d d7	 lea	 rcx, QWORD PTR ar$[rbp-73]
  000e6	e8 00 00 00 00	 call	 inffas8664fnc

; 152  : 
; 153  :     if (ar.status > 1) {

  000eb	8b 4d 4b	 mov	 ecx, DWORD PTR ar$[rbp+43]
  000ee	3b ce		 cmp	 ecx, esi
  000f0	76 39		 jbe	 SHORT $LN20@inflate_fa

; 154  :         if (ar.status == 2)

  000f2	83 f9 02	 cmp	 ecx, 2
  000f5	75 13		 jne	 SHORT $LN6@inflate_fa

; 155  :             strm->msg = "invalid literal/length code";

  000f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@

; 156  :         else if (ar.status == 3)

  000fe	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 157  :             strm->msg = "invalid distance code";
; 158  :         else
; 159  :             strm->msg = "invalid distance too far back";
; 160  :         state->mode = BAD;

  00102	c7 07 1d 00 00
	00		 mov	 DWORD PTR [rdi], 29
  00108	eb 29		 jmp	 SHORT $LN1@inflate_fa
$LN6@inflate_fa:

; 156  :         else if (ar.status == 3)

  0010a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  00111	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
  00118	83 f9 03	 cmp	 ecx, 3
  0011b	48 0f 45 c2	 cmovne	 rax, rdx
  0011f	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 157  :             strm->msg = "invalid distance code";
; 158  :         else
; 159  :             strm->msg = "invalid distance too far back";
; 160  :         state->mode = BAD;

  00123	c7 07 1d 00 00
	00		 mov	 DWORD PTR [rdi], 29
  00129	eb 08		 jmp	 SHORT $LN1@inflate_fa
$LN20@inflate_fa:

; 161  :     }
; 162  :     else if ( ar.status == 1 ) {

  0012b	75 06		 jne	 SHORT $LN1@inflate_fa

; 163  :         state->mode = TYPE;

  0012d	c7 07 0b 00 00
	00		 mov	 DWORD PTR [rdi], 11
$LN1@inflate_fa:

; 164  :     }
; 165  : 
; 166  :     /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
; 167  :     ar.len = ar.bits >> 3;

  00133	8b 4d 2f	 mov	 ecx, DWORD PTR ar$[rbp+15]

; 168  :     ar.in -= ar.len;

  00136	4c 8b 45 e7	 mov	 r8, QWORD PTR ar$[rbp-57]

; 169  :     ar.bits -= ar.len << 3;
; 170  :     ar.hold &= (1U << ar.bits) - 1;
; 171  : 
; 172  :     /* update state and return */
; 173  :     strm->next_in = ar.in;
; 174  :     strm->next_out = ar.out;
; 175  :     strm->avail_in = (unsigned)(ar.in < ar.last ?
; 176  :                                 PAD_AVAIL_IN + (ar.last - ar.in) :
; 177  :                                 PAD_AVAIL_IN - (ar.in - ar.last));
; 178  :     strm->avail_out = (unsigned)(ar.out < ar.end ?
; 179  :                                  PAD_AVAIL_OUT + (ar.end - ar.out) :
; 180  :                                  PAD_AVAIL_OUT - (ar.out - ar.end));
; 181  :     state->hold = (unsigned long)ar.hold;
; 182  :     state->bits = ar.bits;
; 183  :     return;
; 184  : }

  0013a	4c 8d 9c 24 a0
	00 00 00	 lea	 r11, QWORD PTR [rsp+160]
  00142	8b d1		 mov	 edx, ecx
  00144	c1 ea 03	 shr	 edx, 3
  00147	8b c2		 mov	 eax, edx
  00149	4c 2b c0	 sub	 r8, rax
  0014c	8d 04 d5 00 00
	00 00		 lea	 eax, DWORD PTR [rdx*8]
  00153	2b c8		 sub	 ecx, eax
  00155	4c 89 03	 mov	 QWORD PTR [rbx], r8
  00158	d3 e6		 shl	 esi, cl
  0015a	89 4d 2f	 mov	 DWORD PTR ar$[rbp+15], ecx
  0015d	48 8b 4d f7	 mov	 rcx, QWORD PTR ar$[rbp-41]
  00161	8d 46 ff	 lea	 eax, DWORD PTR [rsi-1]
  00164	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  00168	48 89 4b 10	 mov	 QWORD PTR [rbx+16], rcx
  0016c	48 21 45 27	 and	 QWORD PTR ar$[rbp+7], rax
  00170	48 8b 45 ef	 mov	 rax, QWORD PTR ar$[rbp-49]
  00174	49 2b c0	 sub	 rax, r8
  00177	48 83 c0 06	 add	 rax, 6
  0017b	89 43 08	 mov	 DWORD PTR [rbx+8], eax
  0017e	48 8b 45 07	 mov	 rax, QWORD PTR ar$[rbp-25]
  00182	48 2b c1	 sub	 rax, rcx
  00185	48 05 02 01 00
	00		 add	 rax, 258		; 00000102H
  0018b	89 43 18	 mov	 DWORD PTR [rbx+24], eax
  0018e	8b 45 27	 mov	 eax, DWORD PTR ar$[rbp+7]
  00191	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00195	89 47 40	 mov	 DWORD PTR [rdi+64], eax
  00198	8b 45 2f	 mov	 eax, DWORD PTR ar$[rbp+15]
  0019b	89 47 44	 mov	 DWORD PTR [rdi+68], eax
  0019e	49 8b 7b 20	 mov	 rdi, QWORD PTR [r11+32]
  001a2	49 8b e3	 mov	 rsp, r11
  001a5	5d		 pop	 rbp
  001a6	c3		 ret	 0
inflate_fast ENDP
_TEXT	ENDS
END
